+++
title = "productive_programmer"
draft = false
tags = [
    "books",
    "productive_programmer"
]
date = "2013-03-12"
+++
# The Productive Programmer 

Author: Neal Ford<br/><br/>
{{< lib "Productive programmer|Librarything Link" >}}

Dit is een samenvatting van alle **notes** in essentie, opgedeeld per hoofdstuk.

## Part 1: Mechanics 

### Acceleration 

  * Concentrate on essence, not ceremony.
  * The usefulness of an application list is inversely proportional to its length. 
  * Eye candy looks goot but isn't nutritious. 
  * Typing is faster than navigation. 
  * Prefer typing over mousing.
  * The address bar is the most efficient Windows interface. 
  * Take the time to learn all the hidden keyboard shortcuts of your universe.
  * Context switching eats time. 
  * Clipboarding to batches is faster than clipboarding serially. 
  * Those who remember their history aren't doomed to type it again. 
  * Embedded command prompts give you access to the best of both worlds.
  * Embed the command prompt to make it easier to switch contexts.
  * When coding, always prefer the keyboard to the mouse. 
  * Learn the IDE keyboard shortcuts in context, not by reading long lists.
  * When you type a complicated construct for the second time, templatize it.
  * For any symmetric operation on multiple lines of text, find a pattern and record a macro.
  * The more times you perform a particular operation on a chunck of text, the greater the likehood you'll do it again.
  * Don't type the same command over and over again.
  * Spend a little time each day to make every day more productive. 

<img style='float: left; width: nolink&|px;' src='/img//books/angry_monkeys.png'>

### Focus 

  * The higher the level of concentration, the denser the ideas.
  * THe bigger the haystack, the harder it is to find the needle.
  * Replace file hierarchies with search.
  * Try simpler searching before resorting to "hard target" searching.
  * Take advantage of built-in focus facilities like colors.
  * Use links to create virtual project management folders.
  * Virtual desktops unclutter your stacks of windows. 

### Automation 

  * Use tools out of their original context when appropriate. 
  * Don't spend time doing by hand what you can automate.
  * Performing simple, repetitive tasks squanders your concentration.
  * Finding innovatige solutions to problems makes it easier to solve similar problems in the future.
  * Timebox speculative development.

### Canonicality 

  * Keep a single copy of everything you don't build in version control.
  * Use indirection to create friendlier workspaces.
  * Use indirection to keep your life in sync (symlinks).
  * No matter what you are copying and pasting, reuse by copy and paste is evil.
  * Use virtualization to canonicalize dependencies for your projects.
  * Don't let object-relational mapping tools violate canonicality. 
  * Add behavior to generated code via extention, open classes or partial classes. 
  * Always keep code and schemas in sync. 
  * Use migrations to create repeatable snapshots of schema changes. 
  * Out-of-date documentation is worse than none because it is actively misleading.
  * For managers, documentation is about risk mitigation.
  * Always keep "living" documents. 
  * Anything that takes real effort to create makes its creator irrationally attached to it.
  * Whiteboard + digital camera > CASE tools.
  * Generate all the technical documents you can. 
  * Never keep two copies of the same thing. 
  * Repetition is the single most diminishing force in software development.

## Part 2: Practice 

### Statistic analysis 

  * Statistic analysis tools represent cheap verification.

### Good citizenship 

  * Don't create global variables, even the object kind. 

### YAGNI 

  * Don't pay complexity tax unless you absolutely must.
  * Software development is first and foremost a communication game. 

### Ancient philosophers 

  * Maximize work on essential complexity; kill accidental complexity. 
  * Even general-purpose programming languages suffer from the "80-10-10" rule. 
  * Pay attention to the lore of "ancient" technologies. (Smalltalk lol)

### Meta-programming 

  * Meta-programming changes your syntactic vocabulary, giving you more ways to express yourself.

### Composed method and SLAP 

  * Refactoring to composed method reveals hidden reusable code. 
  * TDD predisposes composed method. 
  * Encapuslate all implementation details away from public methods. 

### Find the perfect Tools 

  * Find your perfect editor and learn it inside and out.
  * Record macros for all symmetrical text manipulations.
  * Good knowledge of regexp can save orders of magnitude of effort.
  * Don't make round trips when you can batch. 
  * Use a "real" scripting language for automation chores. 
  * Keep behavior in (testable) code.
  * Pay attention to the evolution of your tools. 
  * Pay as little complexitax as you can. 