<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reflectie on Brain Baking</title>
    <link>http://www.brainbaking.com/tags/reflectie/index.xml</link>
    <description>Recent content in Reflectie on Brain Baking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wouter.groeneveld@gmail.com (Wouter Groeneveld)</managingEditor>
    <webMaster>wouter.groeneveld@gmail.com (Wouter Groeneveld)</webMaster>
    <atom:link href="http://www.brainbaking.com/tags/reflectie/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>reflectie</title>
      <link>http://www.brainbaking.com/wiki/code/csharp/reflectie/</link>
      <pubDate>Mon, 09 Feb 2015 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/csharp/reflectie/</guid>
      <description>

&lt;h1 id=&#34;reflectie&#34;&gt;Reflectie&lt;/h1&gt;

&lt;h2 id=&#34;get-type-based-on-string&#34;&gt;Get Type based on string&lt;/h2&gt;

&lt;p&gt;Probleem: een fully qualified classname in string vorm is geen &lt;code&gt;Type&lt;/code&gt; en &lt;code&gt;Type.GetType()&lt;/code&gt; gaat standaard in de huidige assembly kijken of die klasse daar in steekt. Hoe haal ik dit type op als ik niet vanbuiten weet in welke assembly ik moet gaan kijken? Via uw &lt;code&gt;AppDomain&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;                    return AppDomain.CurrentDomain.GetAssemblies()
                        .Single(app ######&amp;gt; app.GetType(fullClassName) ! null)
                        .GetType(fullClassName);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-subclasses-interfaces-of-class&#34;&gt;Get Subclasses/interfaces of class&lt;/h2&gt;

&lt;p&gt;Gebruik &lt;code&gt;type.Assembly.GetTypes()&lt;/code&gt; en filter verder.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Als je een &lt;strong&gt;interface&lt;/strong&gt; wil hebben, moet je &lt;code&gt;IsAssignableFrom()&lt;/code&gt; gebruiken (in de omgekeerde richting).&lt;/li&gt;
&lt;li&gt;Als je een &lt;strong&gt;subklasse&lt;/strong&gt; wil hebben, moet je ofwel de &lt;code&gt;.BaseType&lt;/code&gt; property gebruiken als direct kind, ofwel de &lt;code&gt;IsSubclassOf()&lt;/code&gt; method.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        public string HandleMessage(IHostService hostService)
        {
            var requestType = typeof (IHostServiceNativeRequest);
            var handlerType = requestType.Assembly.GetTypes()
                                         .Where(requestType.IsAssignableFrom)
                                         .Single(t ######&amp;gt; (NativeRequestInstance(t)).Key  Key);

            return NativeRequestInstance(handlerType).ParseRequest(hostService);
        }

        private IHostServiceNativeRequest NativeRequestInstance(Type t)
        {
            return (IHostServiceNativeRequest) Activator.CreateInstance(t);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reflective-instantiation&#34;&gt;Reflective instantiation&lt;/h2&gt;

&lt;p&gt;Zie vorig voorbeeld; een nieuwe instantie van een &lt;code&gt;Type&lt;/code&gt; maken kan via &lt;code&gt;Activator.CreateInstance()&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;protected-constructor-with-arguments&#34;&gt;Protected constructor with arguments&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;            return (T)Activator.CreateInstance(typeof(T),
                BindingFlags.NonPublic | BindingFlags.CreateInstance | BindingFlags.Instance,
                null, new object[] { arg1 }, CultureInfo.CurrentCulture);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;appdomains&#34;&gt;AppDomains&lt;/h2&gt;

&lt;h5 id=&#34;q-ik-wil-een-dll-dynamisch-laden&#34;&gt;Q: Ik wil een DLL dynamisch laden&lt;/h5&gt;

&lt;p&gt;Gebruik &lt;code&gt;Assembly.LoadFrom(string)&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;q-ik-wil-loopen-over-alle-appdomains&#34;&gt;Q: Ik wil loopen over alle AppDomains&lt;/h5&gt;

&lt;p&gt;Niet zo simpel te realiseren: (zie &lt;a href=&#34;http:*stackoverflow.com/questions/14758915/get-all-processes-with-their-corresponding-app-domains&#34;&gt;http:*stackoverflow.com/questions/14758915/get-all-processes-with-their-corresponding-app-domains&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private static List&amp;lt;AppDomainInf&amp;gt; GetAppDomains()
    {
        IList&amp;lt;AppDomain&amp;gt; mAppDomainsList = new List&amp;lt;AppDomain&amp;gt;();
        List&amp;lt;AppDomainInf&amp;gt; mAppDomainInfos = new List&amp;lt;AppDomainInf&amp;gt;();

        IntPtr menumHandle = IntPtr.Zero;
        ICorRuntimeHost host = new CorRuntimeHost();

        try
        {
            host.EnumDomains(out menumHandle);
            object mTempDomain = null;

            //add all the current app domains running
            while (true)
            {
                host.NextDomain(menumHandle, out mTempDomain);
                if (mTempDomain ###### null) break;
                AppDomain tempDomain = mTempDomain as AppDomain;
                mAppDomainsList.Add((tempDomain));
            }

            //retrieve every app domains detailed information
            foreach (var appDomain in mAppDomainsList)
            {
                AppDomainInf domainInf = new AppDomainInf();

                domainInf.Assemblies = GetAppDomainAssemblies(appDomain);
                domainInf.AppDomainName = appDomain.FriendlyName;

                mAppDomainInfos.Add(domainInf);
            }

            return mAppDomainInfos;
        }
        catch (Exception)
        {
            throw; //rethrow
        }
        finally
        {
            host.CloseEnum(menumHandle);
            Marshal.ReleaseComObject(host);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ref toevoegen, mscoree.tld in .NET root folder.&lt;/p&gt;

&lt;p&gt;############= Generic Type arguments &amp;amp; reflectie ############=&lt;/p&gt;

&lt;h6 id=&#34;q-ik-wil-een-type-meegeven-dat-moet-extenden-van-een-basisklasse-waarna-ik-dat-type-wil-instantiëren&#34;&gt;Q: Ik wil een Type meegeven dat moet extenden van een basisklasse, waarna ik dat type wil instantiëren.&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;protected IList&amp;lt;TInsertable&amp;gt; Load&amp;lt;TInsertable&amp;gt;() where TInsertable : DatabaseInsertable
{
    var myInstance = Activator.CreateInstance(typeof(TInsertable));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;❗ &lt;code&gt;Type&lt;/code&gt; zelf is niet generic omdat dit at-runtime gebruikt wordt voor typeinformatie en de andere dingen at-compiletime. Je kan dus geen &lt;code&gt;Type&amp;lt;T&amp;gt; where T : MyClass&lt;/code&gt; gebruiken, zoals in Java bijvoorbeeld &lt;code&gt;Class&amp;lt;? extends MyClass&amp;gt;&lt;/code&gt; gebruikt wordt. Merk op dat in Java er met het generic type argument geen klasse aangemaakt kan worden, zie &lt;a href=&#34;http://www.brainbaking.com/wiki/code/java/reflectie/&#34;&gt;code/java/reflectie&lt;/a&gt; voor java.&lt;/p&gt;

&lt;h6 id=&#34;q-ik-wil-een-variabel-aantal-generic-type-argumenten-definiëren&#34;&gt;Q: Ik wil een variabel aantal generic type argumenten definiëren&lt;/h6&gt;

&lt;p&gt;Genaaid, dit gaat niet. Kijk maar naar bijvoorbeeld &lt;code&gt;Func&amp;lt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Func&amp;lt;in T1, in T2, out Result&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Func&amp;lt;in T1, in T2, in T3, out Result&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Func&amp;lt;in T1, in T2, in T3, in T4, out Result&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Je kan die wel allemaal laten refereren naar één (private) methode die &lt;code&gt;params[]&lt;/code&gt; gebruikt, bijvoorbeeld onderstaande count:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        protected int Count&amp;lt;TInsertable&amp;gt;()
            where TInsertable : DatabaseInsertable
        {
            return Count(typeof (TInsertable));
        }

        protected int Count&amp;lt;TInsertable1, TInsertable2&amp;gt;()
            where TInsertable1 : DatabaseInsertable
            where TInsertable2 : DatabaseInsertable
        {
            return Count(typeof (TInsertable1), typeof (TInsertable2));
        }

        protected int Count&amp;lt;TInsertable1, TInsertable2, TInsertable3&amp;gt;() 
            where TInsertable1 : DatabaseInsertable
            where TInsertable2 : DatabaseInsertable
            where TInsertable3 : DatabaseInsertable
        {
            return Count(typeof (TInsertable1), typeof (TInsertable2), typeof (TInsertable3));
        }

        private int Count(params Type[] insertableTypes)
        {
            var count = 0;
            foreach (var type in insertableTypes)
            {
                var select = &amp;quot;select count(*) from &amp;quot; + GetTableOfType(type);
                count += Int32.Parse(factory.CreateCommand(this.connection, select).ExecuteScalar().ToString());
            }
            return count;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;############= Reflectie en dynamisch code genereren ############=&lt;/p&gt;

&lt;p&gt;Mogelijk met &lt;strong&gt;Reflection EMIT&lt;/strong&gt;, om dynamisch IL code te genereren. IL is de bytecode tussenlaag in .NET, die je ook in C# kan schrijven.&lt;/p&gt;

&lt;p&gt;Compleet voorbeeld: &lt;a href=&#34;http://www.codeproject.com/Articles/121568/Dynamic-Type-Using-Reflection-Emit&#34;&gt;http://www.codeproject.com/Articles/121568/Dynamic-Type-Using-Reflection-Emit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bijvoorbeeld, om een getal te delen door een ander met &lt;code&gt;getal / other&lt;/code&gt;, genereert de volgende code dit in IL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;MethodBuilder mDivide = tbuilder.DefineMethod(&amp;quot;Divide&amp;quot;, MethodAttributes.Public |
    MethodAttributes.HideBySig |
    MethodAttributes.NewSlot |
    MethodAttributes.Virtual |
    MethodAttributes.Final,
    CallingConventions.Standard,
    typeof(System.Single),
    new Type[] { typeof(System.Int32), typeof(System.Int32) });
mDivide.SetImplementationFlags(MethodImplAttributes.Managed);
ILGenerator dil = mDivide.GetILGenerator();

dil.Emit(OpCodes.Nop);
Label lblTry = dil.BeginExceptionBlock();

dil.Emit(OpCodes.Nop);
dil.Emit(OpCodes.Ldarg_1);
dil.Emit(OpCodes.Ldarg_2);
dil.Emit(OpCodes.Div);
dil.Emit(OpCodes.Conv_R4); // Converts to Float32
dil.Emit(OpCodes.Stloc_1);
dil.Emit(OpCodes.Leave, lblTry);

dil.BeginCatchBlock(typeof(DivideByZeroException));
dil.Emit(OpCodes.Stloc_0);
dil.Emit(OpCodes.Nop);
dil.Emit(OpCodes.Ldstr, &amp;quot;ZeroDivide exception : {0}&amp;quot;);
dil.Emit(OpCodes.Ldloc_0);
MethodInfo minfo = typeof(DivideByZeroException).GetMethod(&amp;quot;get_Message&amp;quot;);
dil.Emit(OpCodes.Callvirt, minfo);
MethodInfo wl = typeof(System.Console).GetMethod(&amp;quot;WriteLine&amp;quot;, new Type[] 
                                      { typeof(string), typeof(object) });
dil.Emit(OpCodes.Call, wl);
dil.Emit(OpCodes.Nop);
dil.Emit(OpCodes.Ldc_R4, 0.0);
dil.Emit(OpCodes.Stloc_1);
dil.Emit(OpCodes.Leave_S, lblTry);

dil.EndExceptionBlock();
dil.Emit(OpCodes.Nop);
dil.Emit(OpCodes.Ldloc_1);
dil.Emit(OpCodes.Ret);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Genereert dit in IL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.method public hidebysig newslot virtual final 
            instance float32  Divide(int32 firstnum,
                        int32 secondnum) cil managed
    {
        // Code size       39 (0x27)
        .maxstack  2
        .locals init (class [mscorlib]System.DivideByZeroException V_0,
                float32 V_1)
        IL_0000:  nop
        .try
        {
        IL_0001:  nop
        IL_0002:  ldarg.1
        IL_0003:  ldarg.2
        IL_0004:  div
        IL_0005:  conv.r4
        IL_0006:  stloc.1
        IL_0007:  leave.s    IL_0024
        }  // end .try
        catch [mscorlib]System.DivideByZeroException 
        {
        IL_0009:  stloc.0
        IL_000a:  nop
        IL_000b:  ldstr      &amp;quot;ZeroDivide exception : {0}&amp;quot;
        IL_0010:  ldloc.0
        IL_0011:  callvirt   instance string [mscorlib]System.Exception::get_Message()
        IL_0016:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                        object)
        IL_001b:  nop
        IL_001c:  ldc.r4     0.0
        IL_0021:  stloc.1
        IL_0022:  leave.s    IL_0024
        }  // end handler
        IL_0024:  nop
        IL_0025:  ldloc.1
        IL_0026:  ret
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>reflectie</title>
      <link>http://www.brainbaking.com/wiki/code/ruby/reflectie/</link>
      <pubDate>Tue, 11 Mar 2014 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/ruby/reflectie/</guid>
      <description>

&lt;h1 id=&#34;metaprogrammeren-ruby-reflectie&#34;&gt;Metaprogrammeren: Ruby Reflectie&lt;/h1&gt;

&lt;h3 id=&#34;methods-accessen&#34;&gt;Methods accessen&lt;/h3&gt;

&lt;p&gt;Dit kan op twee manieren: op een object &lt;strong&gt;instance&lt;/strong&gt; of op een &lt;strong&gt;class&lt;/strong&gt;, met &lt;code&gt;.method&lt;/code&gt; of &lt;code&gt;.static_method&lt;/code&gt;, zie &lt;a href=&#34;http://www.ruby-doc.org/core-2.1.1/Method.html&#34;&gt;Ruby Method doc&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;1.method(:+).call 2 # output: 3
Fixnum.static_method(:+).bind(1).call 2 # output: 3
1.method(&amp;quot;+&amp;quot;).unbind().bind(1).call(2) # output: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object Methods zijn al gebind en kan je dus losmaken van hun reference indien gewenst - zelfde effect als de &lt;code&gt;static_method&lt;/code&gt; call. Je kan blijkbaar zowel een string als een ref meegeven om de naam van de method te resolven.&lt;/p&gt;

&lt;h5 id=&#34;ik-wil-meer&#34;&gt;Ik wil meer&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;1.methods.each{|x| puts x}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;of &lt;code&gt;.static_methods&lt;/code&gt; natuurlijk. Enkel public of protected, ook van subklassen.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>reflectie</title>
      <link>http://www.brainbaking.com/wiki/code/java/reflectie/</link>
      <pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/java/reflectie/</guid>
      <description>

&lt;h1 id=&#34;reflectie-classpath-scanning-etc&#34;&gt;Reflectie, Classpath scanning etc&lt;/h1&gt;

&lt;h3 id=&#34;oplijsten-van-fields-die-enkel-boolean-en-true-zijn&#34;&gt;Oplijsten van fields die enkel boolean en true zijn&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public static String listTrueBooleanFields(Object object) {
		List&amp;lt;String&amp;gt; parts = Lists.newArrayList();
		try {
			for (Field field : object.getClass().getDeclaredFields()) {
				boolean accessibleFlag = field.isAccessible();
				field.setAccessible(true);
				if (isTrueBooleanField(object, field)) {
					parts.add(makeCamelCaseNatural(field.getName()));
				}
				field.setAccessible(accessibleFlag);
			}
		} catch (Exception ex) {
			throw new RuntimeException(ex);
		}

		return StringUtils.join(parts, &amp;quot;, &amp;quot;);
	}

	private static boolean isTrueBooleanField(Object object, Field field) throws IllegalAccessException {
		return isBoolean(field) &amp;amp;&amp;amp; (Boolean) field.get(object);
	}

	private static boolean isBoolean(Field field) {
		return Boolean.class.isAssignableFrom(field.getType()) || boolean.class.isAssignableFrom(field.getType());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nieuwe-instantie-van-een-klasse-met-default-constructor&#34;&gt;Nieuwe instantie van een klasse met default constructor&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ReflectionUtils {

	public static &amp;lt;T&amp;gt; T createNewInstanceOf(Class&amp;lt;T&amp;gt; classToCreate) {
		try {
			Constructor&amp;lt;T&amp;gt; noArgConstructor = classToCreate.getDeclaredConstructor();

			boolean accessibleFlag = noArgConstructor.isAccessible();
			noArgConstructor.setAccessible(true);

			T newInstance = noArgConstructor.newInstance();

			noArgConstructor.setAccessible(accessibleFlag);
			return newInstance;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;class-files-vinden-in-bepaalde-packages&#34;&gt;Class files vinden in bepaalde packages&lt;/h3&gt;

&lt;h4 id=&#34;met-spring&#34;&gt;Met Spring&lt;/h4&gt;

&lt;p&gt;Met hulp van spring classes zoals &lt;code&gt;org.springframework.core.io.support.ResourcePatternResolver&lt;/code&gt; en &lt;code&gt;org.springframework.core.type.classreading.MetadataReaderFactory&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					ClassUtils.convertClassNameToResourcePath(basePackage) + &amp;quot;/&amp;quot; + this.resourcePattern;
			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);

			for (int i = 0; i &amp;lt; resources.length; i++) {
				Resource resource = resources[i];
				MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
				if (isCandidateComponent(metadataReader)) {
					Class&amp;lt;?&amp;gt; clazz = null;
					try {
						clazz = Class.forName(metadataReader.getClassMetadata().getClassName());
					} catch (ClassNotFoundException e) {
						e.printStackTrace();
					}
					candidates.add(clazz);
				}
			}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CLASSPATH_ALL_URL_PREFIX&lt;/code&gt; is &lt;strong&gt;&lt;code&gt;&amp;quot;classpath*:&amp;quot;&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;De &lt;code&gt;isCandidateComponent&lt;/code&gt; method accepteert of verwerpt een item afhankelijk van de metadata met hulp van de spring interface &lt;code&gt;org.springframework.core.type.filter.TypeFilter&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
				return true;
			}
		}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Het is ook mogelijk om een &amp;ldquo;default&amp;rdquo; filter te voorzien die alles include: &lt;code&gt;new RegexPatternTypeFilter(Pattern.compile(&amp;quot;.*&amp;quot;));&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;subtypes-van-een-bepaalde-klasse-vinden&#34;&gt;Subtypes van een bepaalde klasse vinden&lt;/h5&gt;

&lt;p&gt;Kan ook met de bovenstaande code (de &lt;code&gt;ClassPathScanningCandidateComponentProvider&lt;/code&gt; dus):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public &amp;lt;T&amp;gt; Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getSubTypesOf(Class&amp;lt;T&amp;gt; type) {
		ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false);
		provider.addIncludeFilter(new AssignableTypeFilter(type));
		Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; candidateSubtypes = provider.findCandidateComponents(getPackageToScan());
		candidateSubtypes.remove(type);
		return candidateSubtypes;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;get-only-concrete-subclasses&#34;&gt;get only concrete subclasses&lt;/h5&gt;

&lt;p&gt;In combinatie met bovenstaande method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public &amp;lt;T&amp;gt; Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getConcreteSubTypesOf(Class&amp;lt;T&amp;gt; type) {
		Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; result = new HashSet&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();
		for (Class&amp;lt;?&amp;gt; aClass : getSubTypesOf(type)) {
			if (isConcrete(aClass)) {
				result.add(aClass);
			}
		}
		return result;
	}

	private boolean isConcrete(Class&amp;lt;?&amp;gt; aClass) {
		return !Modifier.isAbstract(aClass.getModifiers());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;zonder-spring&#34;&gt;Zonder Spring&lt;/h4&gt;

&lt;p&gt;Gebruik &lt;a href=&#34;http://code.google.com/p/reflections/&#34;&gt;http://code.google.com/p/reflections/&lt;/a&gt; -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Reflections reflections = new Reflections(&amp;quot;my.project.prefix&amp;quot;);
Set&amp;lt;Class&amp;lt;? extends SomeClassOrInterface&amp;gt;&amp;gt; subTypes = reflections.getSubTypesOf(SomeClassOrInterface.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;alles-zelf-doen&#34;&gt;Alles zelf doen?&lt;/h4&gt;

&lt;p&gt;Slecht idee, enige optie is alle class files van het classpath als files behandelen, &lt;code&gt;Class.forName&lt;/code&gt; gebruiken om classes in te laden (&lt;strong&gt;slecht idee&lt;/strong&gt;) en &lt;code&gt;instanceof&lt;/code&gt; ofzoiets gebruiken. Bytecode scanning gebeurt door de twee bovenstaanden, maar is niet triviaal zelf te doen.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>