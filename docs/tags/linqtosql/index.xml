<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linqtosql on Brain Baking</title>
    <link>http://www.brainbaking.com/tags/linqtosql/index.xml</link>
    <description>Recent content in Linqtosql on Brain Baking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wouter.groeneveld@gmail.com (Wouter Groeneveld)</managingEditor>
    <webMaster>wouter.groeneveld@gmail.com (Wouter Groeneveld)</webMaster>
    <atom:link href="http://www.brainbaking.com/tags/linqtosql/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linqtosql</title>
      <link>http://www.brainbaking.com/wiki/code/csharp/linqtosql/</link>
      <pubDate>Tue, 14 Jul 2015 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/csharp/linqtosql/</guid>
      <description>

&lt;h1 id=&#34;code-csharp-linqtosql&#34;&gt;code:csharp &amp;gt;&amp;gt; Linqtosql&lt;/h1&gt;

&lt;p&gt;Zie ook &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/bb425822.aspx&#34;&gt;MSDN LinqToSql pagina&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;

&lt;p&gt;Principe is een &lt;strong&gt;DataContext&lt;/strong&gt; object aanmaken waar je je connectionstring aan meegeeft (&lt;code&gt;Log&lt;/code&gt; kan naar &lt;code&gt;Console.Out&lt;/code&gt; ofzo). Vanaf dan via het context object werken:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;context.GetTable&amp;lt;T&amp;gt;().Where(t ######&amp;gt; t.Property  x).ToList()&lt;/code&gt; om te queryen&lt;/li&gt;
&lt;li&gt;bij deleten of wijzigen: &lt;code&gt;.Attach(entity)&lt;/code&gt; en &lt;code&gt;.DeleteOnSubmit(entity)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Modellen: annoteren met &lt;code&gt;[Table(Name######&amp;quot;tabelnaam&amp;quot;)]&lt;/code&gt;, kolommen met &lt;code&gt;[Column(Name&amp;quot;kolomnaam&amp;quot;, IsPrimaryKey ###### true, IsDbGenerated  true)]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Wijzigingen doorvoeren met &lt;code&gt;SubmitChanges()&lt;/code&gt; door simpelweg properties van modellen te wijzigen, zoals een &amp;ldquo;echte&amp;rdquo; ER tool.&lt;/p&gt;

&lt;h2 id=&#34;advanced&#34;&gt;Advanced&lt;/h2&gt;

&lt;h4 id=&#34;manytoone-relaties-en-domain-driven-design&#34;&gt;ManyToOne relaties en domain driven design&lt;/h4&gt;

&lt;p&gt;In het model: &lt;code&gt;[Association(ThisKey ###### &amp;quot;ReferenceId&amp;quot;, IsForeignKey  true)]&lt;/code&gt; attribuut toevoegen.&lt;/p&gt;

&lt;p&gt;Als je een Fetch wil doen en associaties ook wenst op te halen moet je dit &lt;strong&gt;altijd meegeven&lt;/strong&gt;: &lt;code&gt;new DataLoadOptions().LoadWith&amp;lt;T&amp;gt;(t =&amp;gt; t.AssociationProperty)&lt;/code&gt;. Ook deze loadoptions meegeven aan de context.&lt;/p&gt;

&lt;p&gt;Indien dit overgeslagen wordt, zal bij een ToList in LINQ die property niet opgehaald worden. Dit is vervelend om elke keer mee te geven - kan ook generiek, bijvoorbeeld zo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        private static void AddLoadOptions&amp;lt;T&amp;gt;(DataContext context) where T : class, new()
        {
            if (IsAssociation&amp;lt;T&amp;gt;())
            {
                var loadOps = new DataLoadOptions();
                ((IAssociationModel)new T()).AssociationsToLoad(loadOps);
                context.LoadOptions = loadOps;
            }
        }

        private static bool IsAssociation&amp;lt;T&amp;gt;() where T : class, new()
        {
            return typeof(IAssociationModel).IsAssignableFrom(typeof(T));
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AddLoadOptions&lt;/code&gt; altijd aanroepen wanneer een fetch in een repository zou gebeuren. Dit zit er op de interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;    public interface IAssociationModel
    {
        IList&amp;lt;object&amp;gt; AssocationsToAttach();

        void AssociationsToLoad(DataLoadOptions loadOps);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zo kan iedere entiteit zijn eigen &lt;code&gt;LoadWith&lt;/code&gt; oproepen.&lt;/p&gt;

&lt;h4 id=&#34;transacties&#34;&gt;Transacties&lt;/h4&gt;

&lt;p&gt;Gebruik &lt;code&gt;TransactionScope&lt;/code&gt; object, aanmaken voor je iets doet en &lt;code&gt;.Complete()&lt;/code&gt; of &lt;code&gt;.Dispose()&lt;/code&gt; oproepen. &lt;br/&gt;&lt;br/&gt;
Om dit niet de helel tidj zelf te moeten beheren, complexiteit opbergen in een basis Repository klasse, zoiets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;            using (var repo = Repository.Instance.Transactional())
            {
               Fetch(); // ...
               Delete(); 
               // ...
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;om dan in de &lt;code&gt;Dispose()&lt;/code&gt; de transactie te completen. De transactionele method maakt een scope aan.&lt;/p&gt;

&lt;h2 id=&#34;compleet-voorbeeld-repository&#34;&gt;Compleet voorbeeld repository&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-chsarp&#34;&gt;    public class Repository : IRepository
    {
        private readonly string _ConnectionString;

        private DataContext _CurrentContext;
        private TransactionScope _TransactionScope;

        public Repository(string connectionString)
        {
            _ConnectionString = connectionString;
        }

        private Repository(Repository baseRepo)
            : this(baseRepo._ConnectionString)
        {
            _CurrentContext = CreateContext();
            _TransactionScope = new TransactionScope();
        }

        public static IRepository Instance { get; set; }

        private bool InTransaction
        {
            get { return _TransactionScope != null; }
        }

        public void Add&amp;lt;T&amp;gt;(T entity) where T : class, new()
        {
            InContext(context =&amp;gt;
            {
                var table = context.GetTable&amp;lt;T&amp;gt;();

                if (IsAssociation&amp;lt;T&amp;gt;())
                {
                    foreach (var toAttach in ((IAssociationModel)entity).AssocationsToAttach())
                    {
                        context.GetTable(toAttach.GetType()).Attach(toAttach);
                    }
                }
                table.InsertOnSubmit(entity);
            });
        }

        public void Add&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; entities) where T : class
        {
            InContext(context =&amp;gt; context.GetTable&amp;lt;T&amp;gt;().InsertAllOnSubmit(entities));
        }

        public void CommitChanges&amp;lt;T&amp;gt;(T entity) where T : class
        {
            InContext(context =&amp;gt;
            {
                var entityTable = context.GetTable&amp;lt;T&amp;gt;();
                if (!InTransaction)
                {
                    entityTable.Attach(entity);
                }
                context.Refresh(RefreshMode.KeepCurrentValues, entity);
            });
        }

        public int Count&amp;lt;T&amp;gt;(ICanModifyIQueryable&amp;lt;T&amp;gt; queryModifier) where T : class, new()
        {
            return InContext(context =&amp;gt;
            {
                AddLoadOptions&amp;lt;T&amp;gt;(context);

                IQueryable&amp;lt;T&amp;gt; list = context.GetTable&amp;lt;T&amp;gt;();

                list = queryModifier.ModifyForCount(list);

                return list.Count();
            });
        }

        public void Delete&amp;lt;T&amp;gt;(T entity) where T : class
        {
            InContext(context =&amp;gt;
            {
                var entityTable = context.GetTable&amp;lt;T&amp;gt;();
                if (!InTransaction)
                {
                    entityTable.Attach(entity);
                }
                entityTable.DeleteOnSubmit(entity);
            });
        }

        public void Dispose()
        {
            CompleteTransaction();
        }

        public List&amp;lt;T&amp;gt; Fetch&amp;lt;T&amp;gt;() where T : class, new()
        {
            return InContext(context =&amp;gt;
            {
                AddLoadOptions&amp;lt;T&amp;gt;(context);
                return context.GetTable&amp;lt;T&amp;gt;().ToList();
            });
        }

        public List&amp;lt;T&amp;gt; FetchBy&amp;lt;T&amp;gt;(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; whereClause) where T : class, new()
        {
            return InContext(context =&amp;gt;
            {
                AddLoadOptions&amp;lt;T&amp;gt;(context);

                return context.GetTable&amp;lt;T&amp;gt;()
                    .Where(whereClause)
                    .ToList();
            });
        }

        public List&amp;lt;T&amp;gt; FetchBy&amp;lt;T&amp;gt;(ICanModifyIQueryable&amp;lt;T&amp;gt; queryModifier) where T : class, new()
        {
            return InContext(context =&amp;gt;
            {
                AddLoadOptions&amp;lt;T&amp;gt;(context);

                IQueryable&amp;lt;T&amp;gt; list = context.GetTable&amp;lt;T&amp;gt;();

                list = queryModifier.Modify(list);

                return list.ToList();
            });
        }

        public IRepository Transactional()
        {
            return new Repository(this);
        }

        private static void AddLoadOptions&amp;lt;T&amp;gt;(DataContext context) where T : class, new()
        {
            if (IsAssociation&amp;lt;T&amp;gt;())
            {
                var loadOps = new DataLoadOptions();
                ((IAssociationModel)new T()).AssociationsToLoad(loadOps);
                context.LoadOptions = loadOps;
            }
        }

        private static bool IsAssociation&amp;lt;T&amp;gt;() where T : class, new()
        {
            return typeof(IAssociationModel).IsAssignableFrom(typeof(T));
        }

        private void CompleteTransaction()
        {
            if (_CurrentContext ###### null || !InTransaction)
            {
                return;
            }

            try
            {
                _CurrentContext.SubmitChanges();
                _TransactionScope.Complete();
            }
            finally
            {
                _TransactionScope.Dispose();
                _CurrentContext.Dispose();

                _TransactionScope = null;
                _CurrentContext = null;
            }
        }

        private DataContext CreateContext()
        {
            return new DataContext(_ConnectionString) { Log = Console.Out };
        }

        private void InContext(Action&amp;lt;DataContext&amp;gt; action)
        {
            InContext(context =&amp;gt;
            {
                action(context);
                return true;
            });
        }

        private T InContext&amp;lt;T&amp;gt;(Func&amp;lt;DataContext, T&amp;gt; action)
        {
            var context = _CurrentContext;
            var newContext = false;

            if (context ###### null)
            {
                context = CreateContext();
                newContext = true;
            }

            try
            {
                //      context.Log = Console.Out;
                var value = action(context);
                if (newContext)
                {
                    context.SubmitChanges();
                }
                return value;
            }
            finally
            {
                if (newContext)
                {
                    context.Dispose();
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>