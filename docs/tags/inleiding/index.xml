<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Inleiding on Brain Baking</title>
    <link>http://www.brainbaking.com/tags/inleiding/index.xml</link>
    <description>Recent content in Inleiding on Brain Baking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wouter.groeneveld@gmail.com (Wouter Groeneveld)</managingEditor>
    <webMaster>wouter.groeneveld@gmail.com (Wouter Groeneveld)</webMaster>
    <atom:link href="http://www.brainbaking.com/tags/inleiding/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>inleiding</title>
      <link>http://www.brainbaking.com/wiki/code/javascript/inleiding/</link>
      <pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/javascript/inleiding/</guid>
      <description>

&lt;h1 id=&#34;javascript-inleiding&#34;&gt;Javascript Inleiding&lt;/h1&gt;

&lt;h3 id=&#34;primitives&#34;&gt;Primitives&lt;/h3&gt;

&lt;h4 id=&#34;soorten&#34;&gt;Soorten&lt;/h4&gt;

&lt;p&gt;In javascript zijn er slechts 3 primitives:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; (geassocieerd object: &lt;code&gt;String&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean&lt;/code&gt; (geassocieerd object: &lt;code&gt;Boolean&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;number&lt;/code&gt; (geassocieerd object: &lt;code&gt;Number&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Primitives zijn &lt;strong&gt;immutable&lt;/strong&gt;! Toekennen van properties maakt ook een tijdelijk object aan, dus dit heeft geen nut.&lt;/p&gt;

&lt;h5 id=&#34;soort-afchecken&#34;&gt;Soort afchecken&lt;/h5&gt;

&lt;p&gt;Aangezien JS loosely typed is, kunnen we nooit weten wat er nu in &lt;code&gt;var variabele;&lt;/code&gt; steekt op een bepaald moment in de code.&lt;br/&gt;&lt;br/&gt;
Om dit op te lossen kan men &lt;code&gt;typeof&lt;/code&gt; gebruiken, een functie die een string teruggeeft wat het type van die variabele is.&lt;/p&gt;

&lt;p&gt;Typeof retourneert in het geval van een object, de string &lt;code&gt;object&lt;/code&gt;, in alle andere gevallen de bovenstaande primitive namen.&lt;/p&gt;

&lt;h4 id=&#34;object-coercing&#34;&gt;Object coercing&lt;/h4&gt;

&lt;p&gt;-&amp;gt; &lt;em&gt;(Lees eerst het stuk over objecten etc aub!)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Elk van de primitives worden door Javascript automatisch geconverteerd naar hun object representatie wanneer men properties of functies hierop probeert toe te passen. Bvb:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var someString = &amp;quot;someString&amp;quot;;

someString.indexOf(&amp;quot;String&amp;quot;); // indexOf() wordt op new String(&amp;quot;someString&amp;quot;) opgeroepen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Direct nadat dit geëvalueerd wordt schiet de garbage collector aan de gang en wordt het tijdelijk object verwijderd.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var tekst = &amp;quot;dit is tekst jong&amp;quot;;
tekst.length = 3; // -&amp;gt; String object created &amp;amp; garbage-collected
console.log(tekst); // dit is tekst jong (old primitive value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Het object dat wordt aangemaakt bijhouden en daar de lengte van afkappen is zelfs gevaarlijk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = new String(&amp;quot;ss&amp;quot;);
s.length = 1;

for(var i = 0; i &amp;lt; s.length; i++) {
  console.log(s[i]); // prints only once &#39;s&#39;
}
console.log(s); // prints &#39;ss&#39;??
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Als we weten dat een object aangemaakt wordt zodra we een property oproepen, vraagt een mens zich af, hoe zit dat met &lt;code&gt;number&lt;/code&gt;s? De &lt;code&gt;.&lt;/code&gt; accessor wordt hier gebruikt om komma&amp;rsquo;s voor te stellen&amp;hellip; Wel, aangezien elk object ook values van properties kan retourneren via de &lt;code&gt;[]&lt;/code&gt; operator (zie later), werkt dit dus wel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;21.54[&amp;quot;toFixed&amp;quot;]() // returns 22, way cool!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zie &lt;a href=&#34;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number&#34;&gt;Mozilla MDC Docs: JS Reference: Number&lt;/a&gt; voor wat mogelijke functies zijn op &lt;code&gt;Number&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;objecten-en-functies&#34;&gt;Objecten en Functies&lt;/h3&gt;

&lt;p&gt;Douglas Crockford:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An object is a dynamic collection of properties.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As opposed to &amp;ldquo;&lt;em&gt;instances of classes&lt;/em&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Een &lt;em&gt;functie&lt;/em&gt; in JS kan net zoals andere waarden toegekend worden aan een variabele. Een functie ís in feite een waarde. Dit is anders in bijvoorbeeld Java, een &amp;ldquo;functie&amp;rdquo; (method) is een syntax block code die uitgevoerd kan worden. Wanneer een functie aan een property van een object gekoppeld is spreken we van een method op dat object.&lt;/p&gt;

&lt;p&gt;Een object bevat properties. Een functie is een rij van expressies die één waarde retourneert voor dezelfde input te evalueren. Bekijk een &amp;ldquo;functie&amp;rdquo; als zijn mathematische beschrijving: &lt;code&gt;f(x)&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;object-literals&#34;&gt;Object Literals&lt;/h4&gt;

&lt;p&gt;Een object definiëren gaat heel makkelijk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Ezel = new Object();
Ezel.poten = 4;
Ezel.balk = function() {
   console.log(&amp;quot;iaia met mijn &amp;quot; + this.poten + &amp;quot; poten&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zodra een &lt;code&gt;Object&lt;/code&gt; gemaakt wordt, kunnen eender welke property keys toegekend worden met eender welke variabele. Dit kan ook op een &lt;em&gt;associatieve&lt;/em&gt; manier, bijvoorbeeld &lt;code&gt;Ezel[&amp;quot;poten&amp;quot;] = 4;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Bekijk het volgend stukje code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Ezel = {
  poten: 4,
  balk: function() {
    console.log(&amp;quot;iaia met mijn &amp;quot; + this.poten + &amp;quot; poten&amp;quot;);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hier wordt een object door middel van een &lt;strong&gt;literal&lt;/strong&gt; gedefiniëerd. De correcte manier om de ezel te laten balken is &lt;code&gt;Ezel.balk()&lt;/code&gt;. Merk op dat &lt;code&gt;Ezel&lt;/code&gt; een gewoon object met wat simpele properties is, bekijk het als een map. Dit is een instantie van &lt;code&gt;Object&lt;/code&gt;: &lt;code&gt;typeof Ezel&lt;/code&gt; retourneert dit.&lt;/p&gt;

&lt;h5 id=&#34;json-en-object-literals&#34;&gt;JSON en Object Literals&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;http://www.json.org/js.html&#34;&gt;JSON&lt;/a&gt; ((JavaScript Object Notation)) is een subset van JavaScript, dus door de JS Compiler op te roepen met &lt;code&gt;eval()&lt;/code&gt; is het heel eenvoudig om JSON Strings te evalueren. Een JSON Object is in feite een JS Object Literal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var JSONObj = {
  &amp;quot;bindings&amp;quot;: [
    { &amp;quot;key&amp;quot;: &amp;quot;value1&amp;quot;, &amp;quot;key2&amp;quot;: &amp;quot;value2&amp;quot; },
    { &amp;quot;key&amp;quot;: &amp;quot;value3&amp;quot;, &amp;quot;key2&amp;quot;: &amp;quot;value4&amp;quot; }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dat object kan via een string opgebouwd worden door &lt;code&gt;eval()&lt;/code&gt; te gebruiken, maar dit is &lt;strong&gt;gevaarlijk&lt;/strong&gt; aangezien van een externe webserver ook JS functies in dat data object kunnen zitten! Gebruik daarvoor altijd een JSON Parser, zoals de built-in &lt;code&gt;JSON.parse()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Om de omgekeerde weg uit te gaan, van object naar string, gebruik &lt;code&gt;JSON.stringify()&lt;/code&gt;. Meer uitleg, zie bovenstaande link.&lt;/p&gt;

&lt;h4 id=&#34;functie-literals&#34;&gt;Functie Literals&lt;/h4&gt;

&lt;p&gt;Een functie definiëren gaat op drie manieren:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;function bla() { ... }&lt;/code&gt; - de normale manier, een &lt;strong&gt;function statement&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var bla = function() { ...}&lt;/code&gt; - een &lt;strong&gt;function literal&lt;/strong&gt;, ofwel een &lt;em&gt;lambda function&lt;/em&gt; (Lisp referentie). In feite een closure die toevallig toegekend wordt aan variabele &lt;code&gt;bla&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var bla = new Function(&amp;quot;&amp;quot;, &amp;quot;...&amp;quot;)&lt;/code&gt; met als eerste argument de argumenten van de functie, allemaal in &lt;code&gt;string&lt;/code&gt; vorm.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;De onderstaande code definiëert bijvoorbeeld in lambda-stijl een functie genaamd Ezel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Ezel = function() {
  this.poten = 4;
  this.balk = function() {
    console.log(&amp;quot;iaia met mijn &amp;quot; + this.poten + &amp;quot; poten&amp;quot;);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merk de verschillen op met het bovenstaande:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function()&lt;/code&gt; staat voor &lt;code&gt;{&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; wordt gebruikt om keys aan te spreken! Waarom? zie &lt;strong&gt;&lt;a href=&#34;http://www.brainbaking.com/wiki/code/javascript/scoping/&#34;&gt;scoping&lt;/a&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;De functie bevat gewone statements met &lt;code&gt;=&lt;/code&gt; en niet met &lt;code&gt;:&lt;/code&gt;. Dit is geen object maar een functie!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;❗ De functie die net aangemaakt is kan nu als constructor dienen. Die werd intern ook aan de Ezel &lt;code&gt;prototype&lt;/code&gt; property gekoppeld:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ezel.prototype.constructor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De correcte manier om de ezel te laten balken is &lt;code&gt;new Ezel().balk()&lt;/code&gt;.&lt;br/&gt;&lt;br/&gt;
Meer info over hoe &lt;code&gt;new&lt;/code&gt; werkt om de ezel instance de poten en de balk functie toe te kennen: zie &lt;a href=&#34;http://www.brainbaking.com/wiki/code/javascript/inheritance/&#34;&gt;code/javascript/inheritance&lt;/a&gt;.&lt;/p&gt;

&lt;h5 id=&#34;functies-zijn-objecten&#34;&gt;Functies zijn objecten&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Functions are first class Objects!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Bewijs: (Uitleg: zie &lt;a href=&#34;http://www.brainbaking.com/wiki/code/javascript/inheritance/&#34;&gt;inheritance&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Function.prototype.__proto__ ##### Object.prototype;
(function fn(){}).__proto__ ##### Function.prototype;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dus functies zijn &lt;em&gt;ook&lt;/em&gt; associatieve maps, dus &lt;code&gt;(function(){}).bla = 3;&lt;/code&gt; werkt perfect! Zie &lt;a href=&#34;http://www.brainbaking.com/wiki/code/javascript/scoping/&#34;&gt;scoping&lt;/a&gt;, deel &amp;ldquo;Object/Class Member variables&amp;rdquo;.&lt;/p&gt;

&lt;h5 id=&#34;de-kracht-van-closures&#34;&gt;De kracht van closures&lt;/h5&gt;

&lt;p&gt;In Javascript is élke functie een &lt;em&gt;closure&lt;/em&gt;! In sommige andere talen kan enkel een closure &amp;ldquo;deep bindings&amp;rdquo; uitvoeren (= scope chain bijhouden, zie scoping deel), of een functie opnieuw retourneren. In JS is er geen verschil tussen een literal function en een gewone, buiten de notatie - een literal bind een anonieme functie aan een variabele. Zoiets kan dus perfect:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = function() {
  var aGetal = 10;
  return function() {
    var bGetal = 20;
    return function() {
      var cGetal = 30;
      
      return aGetal + bGetal + cGetal;
    }
  }
}

a()()() // 60
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merk op dat de &lt;code&gt;()&lt;/code&gt; operator een functie uivoert, en hier alles 3x genest is, maar toch de binnenste functie een referentie naar &lt;code&gt;aGetal&lt;/code&gt; kan gebruiken, gedefiniëert in de buitenste functie! Lees hierover meer in het scoping gedeelte.&lt;/p&gt;

&lt;h5 id=&#34;declaratie-van-functie-literals&#34;&gt;Declaratie van functie literals&lt;/h5&gt;

&lt;p&gt;In javascript worden variabelen die met &lt;code&gt;var&lt;/code&gt; gedeclareerd worden &lt;strong&gt;altijd&lt;/strong&gt; vooraan geplaatst, ook impliciet. Dit wil zeggen dat wanneer ik een function literal definieer, eigenlijk het volgende gebeurt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function x() {
  alert(&amp;quot;yo&amp;quot;);
  var b = function() { };
} // is for the JS parser equal to:

function xParsed() {
  var b;
  alert(&amp;quot;yo&amp;quot;);
  b = function() { };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wanneer je &lt;code&gt;b()&lt;/code&gt; probeert uit te voeren vóórdat b effectief geïnitialiseerd is, ontploft de boel. Let hier dus op, en gebruik als dit niet mogelijk is geen literal. Bij naamgevingen binnen een scope geldt een volgorde:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Language-defined (&lt;code&gt;this&lt;/code&gt;, &lt;code&gt;arguments&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Formal-defined (arguments)&lt;/li&gt;
&lt;li&gt;Function-defined&lt;/li&gt;
&lt;li&gt;Variable-defined&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Dat wil zeggen dat wanneer je twee keer x probeert toe te kennen aan een getal én een functie, heeft de functie voorrang.&lt;/p&gt;

&lt;p&gt;❗ Uitzondering: een formeel argument met naam &lt;code&gt;arguments&lt;/code&gt; heeft voorrang op lang-defined &lt;code&gt;arguments&lt;/code&gt;. Bad practice&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;itereren-over-properties-van-objecten&#34;&gt;Itereren over properties van objecten&lt;/h5&gt;

&lt;p&gt;Vergeet niet dat in Javascript alle objecten (zowel object literals als instanties van functies) zich gedragen als een &lt;a href=&#34;https://en.wikipedia.org/wiki/Associative%20array&#34; target=&#34;_blank&#34;&gt;Associative array&lt;/a&gt;
 - en dat we dus ook kunnen lopen over alle keys:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var N = { one: 1, two: 2 };
for(key in N) {
  console.log(key + &amp;quot; represents as value: &amp;quot; + N[key]); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Om de value van een bepaalde key op te halen kan je natuurlijk ook &lt;code&gt;eval(&#39;N.&#39; + key)&lt;/code&gt; gebruiken - alle wegen leiden tot Rome&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;controleren-of-een-key-in-een-object-array-beschikbaar-is&#34;&gt;Controleren of een key in een object/array beschikbaar is&lt;/h5&gt;

&lt;p&gt;Dit kan op enkele manieren:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&#39;key&#39; in object&lt;/code&gt; ((Opgelet: &lt;code&gt;in&lt;/code&gt; kan misleidend effect hebben bij gebruik in combinatie met prototypal inheritance, zie later!))&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.hasOwnProperty(&#39;key&#39;)&lt;/code&gt; -&amp;gt; gaat wel &lt;code&gt;false&lt;/code&gt; retourneren bij overgenomen keys vanuit prototypes. Zie later.&lt;/li&gt;
&lt;li&gt;nogmaals itereren (er zijn betere ideeën, dit is de neiging die veel mensen hebben, te procedureel denken!)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Wat géén goede manier is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Obj = {
  x: &#39;x&#39;,
  u: null,
  un: undefined
};

Obj.x ###### undefined // false, so it must exist as a key, right?
Obj.u ###### undefined // whoops, true? oplossing: gebruik &#39;#####&#39;
Obj.un ##### undefined // whoops, still true? value kan ook undefined zijn natuurlijk!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#####= Varargs #####=&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f() {
  return arguments[0] + arguments[1];
}
f(1, 2) // ###### 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Indien er geen argumenten gespecifiëerd zijn, zijn ze allemaal &lt;em&gt;optioneel&lt;/em&gt;! Dit wil zeggen dat een functie aangeroepen kan worden zonder het aantal argumenten 100% te laten overeen komen.&lt;/p&gt;

&lt;h6 id=&#34;anonymus-functions-en-recursie&#34;&gt;anonymus functions en recursie&lt;/h6&gt;

&lt;p&gt;&lt;code&gt;arguuments&lt;/code&gt; heeft nog een speciale property: &lt;code&gt;arguments.callee(...)&lt;/code&gt; dat de huidige functie voorstelt, hiermee kan je jezelf aanroepen!&lt;/p&gt;

&lt;p&gt;❗ Dit gaat een syntax error geven bij ECMA Script standaard 5 in &lt;em&gt;strict&lt;/em&gt; mode&lt;/p&gt;

&lt;h6 id=&#34;verplicht-alle-argumenten-invullen&#34;&gt;verplicht alle argumenten invullen&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f(x, y, z) {
  if(arguments.length != arguments.callee.length) {
    throw new Error(&amp;quot;kapot wabezig&amp;quot;);
  }
}
f(1, 2) // ###### 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Het is natuurlijk makkelijker om &lt;code&gt;!= 3&lt;/code&gt; hardcoded te plaatsen, maar dit kan extracted worden naar een aparte functie.&lt;/p&gt;

&lt;h6 id=&#34;function-overloading&#34;&gt;Function overloading&lt;/h6&gt;

&lt;p&gt;Overloading bestaat niet in JS aangezien de tweede definitie van de functie de eerste overschrijft (de property &amp;ldquo;functienaam&amp;rdquo; in het object, zeg maar). &lt;br/&gt;&lt;br/&gt;
Het is wel mogelijk om één functie te maken die delegeert, zie &lt;a href=&#34;http://ejohn.org/blog/javascript-method-overloading/&#34;&gt;http://ejohn.org/blog/javascript-method-overloading/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Maak handig gebruik van het feit dat de &lt;code&gt;.length&lt;/code&gt; property ook op functies opgeroepen kunnen worden! (Telt enkel de gedefiniëerde)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function x(y, z) {}).length ###### 2; // y and z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#####= this Keyword #####=&lt;/p&gt;

&lt;p&gt;Zie &lt;a href=&#34;http://www.brainbaking.com/wiki/code/javascript/scoping/&#34;&gt;scoping&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#####= Aspect Oriented Programming in JS #####=&lt;/p&gt;

&lt;p&gt;Via AOP kan men net voor of na een bepaalde functie gedrag toevoegen zonder dat een component dat die functie aanroept daar weet van heeft. Het is zo makkelijk om bijvoorbeeld logging toe te voegen. In Java wordt Spring AOP gedaan via proxy beans die van dezelfde interface afleiden en daarna delegeren, of via AspectJ die rechtstreeks bytecode wijzigt.&lt;/p&gt;

&lt;p&gt;In Javascript kan dat makkelijker, omdat we de referentie naar een functie gewoon kunnen &amp;ldquo;vast&amp;rdquo; pakken. Stel dat ik voordat de ezel balkt wil loggen &amp;ldquo;ik ga balken&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var oldBalkF = Ezel.prototype.balk; // vereist dat balk via `prototype` werd toegevoegd
Ezel.prototype.balk = function() {
  console.log(&amp;quot;ik ga balken! &amp;quot;);
  oldBalkF.call(this);
}
new Ezel().balk(); // print log eerst
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hier merken we twee dingen op:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;In de nieuwe balk functie kan &lt;strong&gt;niet&lt;/strong&gt; zomaar &lt;code&gt;oldBalkF()&lt;/code&gt; uitgevoerd worden dan is mijn &lt;code&gt;this&lt;/code&gt; referentie naar de ezel instantie weer weg.&lt;/li&gt;
&lt;li&gt;De &lt;code&gt;window&lt;/code&gt; scope werd vervuild door oldBalkF, die nog steeds toegankelijk is. Hier zijn twee oplossingen voor:

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;delete oldBalkF;&lt;/code&gt; na de &lt;code&gt;call&lt;/code&gt; instructie (extra werk)&lt;/li&gt;
&lt;li&gt;Gebruik een anonieme functie die direct uitgevoerd wordt die de scope bewaakt!&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#####= undefined #####=&lt;/p&gt;

&lt;p&gt;Refereren naar een property in een object dat niet bestaat, geeft ons de speciale waarde &lt;code&gt;undefined&lt;/code&gt;.&lt;br/&gt;&lt;br/&gt;
Merk op dat dit &lt;em&gt;niet hezelfde&lt;/em&gt; is als &lt;code&gt;null&lt;/code&gt;. Toch zijn ze gerelateerd:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = {
  one: 1
};
if(x.two ###### null) {
   3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dit geeft 3 omdat &lt;code&gt;x.two ##### undefined&lt;/code&gt; en &lt;code&gt;null ###### undefined&lt;/code&gt;. Aangezien &lt;code&gt;null&lt;/code&gt; in een if test by default &lt;code&gt;true&lt;/code&gt; retourneert, kan de if test korter: &lt;code&gt;if(x.two) { ... }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Zo is het makkelijk om optionele argumenten van functies na te gaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function count(one, two, three) {
  if(!two) two = 0;
  if(!three) three = 0;
  return one + two + three;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;❗ &lt;code&gt;undefined&lt;/code&gt; is een window-scope variabele die initiëel de value &lt;code&gt;undefined&lt;/code&gt; heeft, dit is dus géén keyword, pas op!&lt;/p&gt;

&lt;p&gt;#####= By Value versus By Reference #####=&lt;/p&gt;

&lt;p&gt;^ Type ^ Copied by ^ Passed By ^ Compared by ^
| number | Value | Value | Value |
| boolean | Value | Value | Value |
| string | Immutable | Immutable | Value |
| object | Reference | Reference | Reference |&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>