<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Async on Brain Baking</title>
    <link>http://www.brainbaking.com/tags/async/index.xml</link>
    <description>Recent content in Async on Brain Baking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wouter.groeneveld@gmail.com (Wouter Groeneveld)</managingEditor>
    <webMaster>wouter.groeneveld@gmail.com (Wouter Groeneveld)</webMaster>
    <atom:link href="http://www.brainbaking.com/tags/async/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>async</title>
      <link>http://www.brainbaking.com/wiki/code/javascript/async/</link>
      <pubDate>Wed, 23 Jul 2014 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/javascript/async/</guid>
      <description>

&lt;h1 id=&#34;async-coding-in-js&#34;&gt;Async coding in JS&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/articles/surviving-asynchronous-programming-in-javascript&#34;&gt;Asynchronous programming in JS: APIs interview&lt;/a&gt; (infoQ)&lt;/p&gt;

&lt;h2 id=&#34;het-probleem&#34;&gt;Het probleem&lt;/h2&gt;

&lt;p&gt;Alle events in javascript zijn asynchroon. Dat wil zeggen dat we geen idee hebben wanneer de eigenlijke code uitgevoerd is, en we een &lt;strong&gt;callback closure&lt;/strong&gt; moeten meegeven, die verder werkt als de asynchrone code uitgevoerd is.&lt;/p&gt;

&lt;p&gt;Dit is oké voor 1-2 asynchrone calls. Maar stel u voor dat we 4+ async calls moeten maken om werk gedaan te krijgen. Typisch dingen zoals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;setTimeouts&lt;/li&gt;
&lt;li&gt;animaties (jQuery ea)&lt;/li&gt;
&lt;li&gt;AJAX calls (REST, naar domein logica, bewaren, opvragen, veranderen, &amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;een-integratietest-schrijven-in-js&#34;&gt;Een integratietest schrijven in JS&lt;/h3&gt;

&lt;p&gt;In &lt;em&gt;Java&lt;/em&gt; kunnen we gewoon wat methods oproepen die data persisteert, daarna de eigenlijke &lt;em&gt;asserts&lt;/em&gt; schrijven en eventueel in de &lt;code&gt;@After&lt;/code&gt; met JUnit data cleanup uitvoeren:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DomainObj obj = new DomainObjPersister()
   .withA()
   .withLala(&amp;quot;lala&amp;quot;)
   .persist();

ChildObj child = new ChildObjPersister()
   .withParent(obj)
   .persist();

assertThat(child.getStuff()).isNotEmpty();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Om &lt;code&gt;child&lt;/code&gt; te kunnen persisteren moeten we &lt;code&gt;obj&lt;/code&gt; als parent meegeven, dus die call moet eerst uitgevoerd zijn. Alle persisters gaan naar de database. Dit zou in javascript zoiets zijn=
&lt;img style=&#39;float: left; width: nolink&amp;|px;&#39; src=&#39;http://www.brainbaking.com/img//code/javascript/kill-it-with-fire.gif&#39;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax(&#39;/domain/obj/store&#39;, {
  success: function(obj) {
    $.ajax(&#39;/domain/child/store&#39;, {
      success: function(child) {
        assertThat(child.getStuff()).isNotEmpty();
      }, ...
    });
  },
  type: &#39;PUT&#39;,
  dataType: &#39;json&#39;,
  data: JSON.stringify({ key: &#39;value&#39;, key2: &#39;value2&#39; })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dus een callback wrappen in een callback wrappen in een callback.&lt;/p&gt;

&lt;h4 id=&#34;async-event-loop-hulpjes&#34;&gt;Async event loop hulpjes&lt;/h4&gt;

&lt;p&gt;Zie ook &lt;a href=&#34;http://vimeo.com/96425312&#34;&gt;Philip Roberts: Help, I&amp;rsquo;m stuck in an event-loop&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img style=&#39;float: left; width: nolink |px;&#39; src=&#39;http://www.brainbaking.com/img//code/javascript/476470428_960.jpg&#39;&gt;&lt;/p&gt;

&lt;p&gt;Tooltje om event loop te visualiseren zodat je ziet wat er gebeurt. Breaken in chrome helpt natuurlijk ook, gewoon naar de call stack kijken&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;asynchroon-testen-in-jasmine&#34;&gt;Asynchroon testen in Jasmine&lt;/h4&gt;

&lt;p&gt;Met &lt;strong&gt;Jasmine&lt;/strong&gt; is het (beperkt) mogelijk om te wachten tot dat een stukje werk uitgevoerd is voordat de assertions afgegaan worden. &lt;br/&gt;&lt;br/&gt;
Dit kan op de volgende manier:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
it(&amp;quot;should be green, right??&amp;quot;, function() {
  var asyncCallFinished = false;
  function callback(someObj) {
    asyncCallFinished = true;
  }
  doAsyncCall(callback);

  waitsFor(function() {
    return asyncCallFinished ##### true;
  });

  runs(function() {
     expect(stuff).toBeLotsBetter();
  });

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pitfalls:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ge moet closure scope gebruiken om een variabele bij te houden om te controleren of de async call klaar is in een callback&lt;/li&gt;
&lt;li&gt;Ge moet &lt;code&gt;waitsFor()&lt;/code&gt; gebruiken, intern pollt Jasmine waarschijnlijk gewoon&amp;hellip;&lt;/li&gt;
&lt;li&gt;Ge moet eigenlijke assertions wrappen in &lt;code&gt;runs()&lt;/code&gt; omdat &lt;code&gt;waitsFor()&lt;/code&gt; direct retourneert en opzich async is.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De assertion functiepointers die meegegeven worden met &lt;code&gt;runs()&lt;/code&gt; worden intern opgeslaan en bijgehouden totdat de closure van &lt;code&gt;waitsFor()&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; retourneert. Daarna wordt ook alles pas meegegeven met de Jasmine reporter (logging, output etc). Redelijk omslachtig, aangezien 3+ async calls dan &lt;code&gt;waitsFor()&lt;/code&gt; moeten wrappen. Geen oplossing.&lt;/p&gt;

&lt;h5 id=&#34;asynchroon-testen-met-qunit&#34;&gt;Asynchroon testen met QUnit&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;asyncTest(&amp;quot;should be green, right??&amp;quot;, function() {  
  var stuff = gogo();
  function callback(obj) {
    equal(obj.stuff, 2);
    start();
  }
  
  doAsyncCall(callback);

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pitfalls:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In de callback van uw async stuk code moeten zoals verwacht uw assertions zitten&lt;/li&gt;
&lt;li&gt;Ge moet een speciale test method gebruiken, &lt;code&gt;asyncTest()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ge moet na uw assertions &lt;code&gt;start()&lt;/code&gt; aanroepen (??)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#####== De oplossing #####==&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/willconant/flow-js&#34;&gt;https://github.com/willconant/flow-js&lt;/a&gt; e.a. (of iets zelfgemaakt in die aard).&lt;/p&gt;

&lt;p&gt;Herneem bovenstaande integratietest code in javascript, maar dan met flow.js geschreven:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;flow.exec(
  function() {
    $.ajax(&#39;/domain/obj/store&#39;, {
      success: this,
      type: &#39;PUT&#39;,
      dataType: &#39;json&#39;,
      data: JSON.stringify({ key: &#39;value&#39;, key2: &#39;value2&#39; })
    });  
  },
  function(obj) {
    $.ajax(&#39;/domain/child/store&#39;, {
      success: this, ...
    }); 
  },
  function(child) {
    assertThat(child.getStuff()).isNotEmpty();
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pitfalls:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Error handling wordt opgefreten - gebruik Firebug&amp;rsquo;s &lt;strong&gt;debug on all errors&lt;/strong&gt; knop in de console. (anders mechanisme maken dat ze doorgooit van closure1 naar 2 ea)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curry()&lt;/code&gt; gaat niet lukken aangezien de &lt;code&gt;this&lt;/code&gt; pas in de closure zelf de juiste waarde krijgt.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; moet meegegeven worden als callback, dus te intensief gebruik makend van &lt;code&gt;this&lt;/code&gt; pointer in eigen code kan BOEM geven.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;flow.js geeft het resultaat van closure1 mee als argument aan closure2 (via &lt;code&gt;arguments&lt;/code&gt;) en zo maar door, dat is mega handig.&lt;/p&gt;

&lt;h5 id=&#34;synchrone-code-code-combineren-met-asynchrone-in-flow-js&#34;&gt;Synchrone code code combineren met asynchrone in flow.js&lt;/h5&gt;

&lt;p&gt;Enige minpunt is dat de callback &lt;code&gt;this()&lt;/code&gt; moet expliciet aangeroepen worden om van closureX naar closureY over te stappen! &lt;br/&gt;&lt;br/&gt;
Los dit op met een utility functie:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;flow.sync = function(work) {
  return function() {
    this(work.apply(this, Array.prototype.slice.call(arguments, 0)));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zodat we dit kunnen doen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;flow.exec(
  function() {
    asyncStuff(this);
  },
  flow.sync(function(resultfromPrev) {
    console.log(&amp;quot;lol&amp;quot;); // no this() required afterwards
  }),
  function(resultFromSyncStuff) {
    doMoreAsyncStuff(this);
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;in-een-asynchrone-closure-parallel-werken&#34;&gt;In een asynchrone closure parallel werken&lt;/h5&gt;

&lt;p&gt;Gebruik &lt;code&gt;this.MULTI()&lt;/code&gt; als callback ipv &lt;code&gt;this&lt;/code&gt; (zie voorbeeld hieronder)&lt;/p&gt;

&lt;h5 id=&#34;flow-js-combineren-met-jasmine&#34;&gt;flow.js combineren met Jasmine&lt;/h5&gt;

&lt;p&gt;Om de smeerlapperij van &lt;code&gt;waitsFor()&lt;/code&gt; weg te werken kunnen we ook &lt;code&gt;flow.exec&lt;/code&gt; gebruiken.&lt;/p&gt;

&lt;p&gt;❗ De laatste stap gaat &lt;strong&gt;altijd&lt;/strong&gt; een &lt;code&gt;runs()&lt;/code&gt; moeten bevatten voor de reporter om aan te duiden dat assertions uitgevoerd worden, aangezien de &lt;code&gt;exec()&lt;/code&gt; functie direct retourneert. Dus moeten we 1x wachten, totdat de hele &amp;ldquo;flow&amp;rdquo; gedaan is. We kunnen dit combineren met BDD en een mini-DSL hierrond schrijven. Resultaat:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function when() {
    var flowDone = false;
    var slice = Array.prototype.slice;
    var argsArray = slice.call(arguments, 0);
    var laatsteArgumenten;
    
    argsArray.push(function() {
        laatsteArgumenten = slice.call(arguments, 0);
        flowDone = true;
    });
    
    flow.exec.apply(this, argsArray);
    waitsFor(function() {
        return flowDone ##### true;
    });
    
    return {
        then: function(assertionsFn) {
            runs(function() {
                assertionsFn.apply(this, laatsteArgumenten);
            });
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voorbeeldcode:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
describe(&amp;quot;plaatsen domein&amp;quot;, function() {
    it(&amp;quot;wanneer ik alle plaatsen ophaal, kan ik hier domeinspecifieke functies aan opvragen&amp;quot;, function() {
        var plaatsen;
        when(
            function() {
                DOMEIN.plaatsRepository.bewaarPlaats(plaats, this.MULTI());
                DOMEIN.plaatsRepository.bewaarPlaats(anderePlaats, this.MULTI());
            },
            function() {
                DOMEIN.plaatsRepository.haalPlaatsenOp(this);
            }
        ).then(
            function(opgehaaldePlaatsen) {
                opgehaaldePlaatsen.forEach(function(plaats) {
                    expect(plaats.geefMeting).toBeDefined();
                });
            }
        );
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merk op dat de closure meegeven in &lt;code&gt;then()&lt;/code&gt; (slechts 1 mogelijk voor assertions) als &lt;strong&gt;argument&lt;/strong&gt; het resultaat van de laatste closure in &lt;code&gt;when()&lt;/code&gt; meekrijgt!&lt;/p&gt;

&lt;p&gt;#####== jQuery 1.6: Deferred en piping #####==&lt;/p&gt;

&lt;p&gt;Vanaf &lt;strong&gt;jQuery 1.6&lt;/strong&gt; is het mogelijk om met &lt;code&gt;$.Deferred&lt;/code&gt; te werken, dat het mogelijk maakt om een closure uit te voeren op het moment dat &amp;ldquo;werk&amp;rdquo; gedaan is. Met werk bedoelen we:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;fx: &lt;code&gt;.animate&lt;/code&gt; ea&lt;/li&gt;
&lt;li&gt;http: &lt;code&gt;.ajax&lt;/code&gt; ea&lt;/li&gt;
&lt;li&gt;custom code die zelf een &lt;code&gt;$.Deferred&lt;/code&gt; object retourneren&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;promising-stuff&#34;&gt;Promising stuff&lt;/h5&gt;

&lt;p&gt;Alle async operaties worden aan een &lt;em&gt;queue&lt;/em&gt; toegevoegd van het jQuery element zelf. Je kan op eender welk moment vragen aan dat queue object, dat wanneer alle items zijn verwerkt er iets speciaals uigevoerd wordt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;#blink&#39;).fadeOut().promise().done(function() {
  console.log(&#39;done blinking!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dit kan dus ook met &lt;code&gt;$.ajax&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;zelf-deferred-code-schrijven&#34;&gt;Zelf Deferred code schrijven&lt;/h5&gt;

&lt;p&gt;Maak een deferred object aan door &lt;code&gt;$.Deferred()&lt;/code&gt; aan te roepen. Op dat moment kan je &lt;code&gt;done()&lt;/code&gt; hierop zoals in het vorige voorbeeld aanroepen. Bijvoorbeeld:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function startStuff() {
  var df = $.Deferred();
  setTimeout(1000, function() {
    console.log(&#39;done async call&#39;);
    df.resolve();
  });
  return df.promise();
}

startStuff().done(function() {
  console.log(&#39;really really done with &amp;quot;start stuff&amp;quot;!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;multiple-elements-in-queue-piping&#34;&gt;Multiple elements in queue: piping&lt;/h5&gt;

&lt;p&gt;Stel dat eerst element #1 animatie triggert, dan #2, en daarna nog logica dient te gebeuren. Dit kan ook met &lt;code&gt;$.Deferred&lt;/code&gt;, door &lt;code&gt;.pipe()&lt;/code&gt; te gebruiken om verder te breiden aan de queue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;button&amp;quot;).bind( &amp;quot;click&amp;quot;, function() {
    $(&amp;quot;p&amp;quot;).append( &amp;quot;Started...&amp;quot;);
    var div1 ###### $(&amp;quot;#div1&amp;quot;), div2  $(&amp;quot;#div2&amp;quot;);

    var df = $.Deferred();
    df.pipe(function() {
        return div1.fadeOut(&amp;quot;slow&amp;quot;)
    }).pipe(function() {
        return div2.fadeOut()
    }).done(function() {
        $(&amp;quot;p&amp;quot;).append( &amp;quot;  --  DONE&amp;quot;);
    });
    df.resolve(); 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;❗ Pas op, in de &lt;code&gt;.pipe()&lt;/code&gt; functie moet een nieuw &lt;strong&gt;promised object&lt;/strong&gt; geretourneerd worden! Dat nieuw object wordt als return value van de vorige pipe gebruikt. Op die manier wordt er dus &lt;em&gt;chaining&lt;/em&gt; toegepast.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>