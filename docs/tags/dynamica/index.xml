<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamica on Brain Baking</title>
    <link>http://www.brainbaking.com/tags/dynamica/index.xml</link>
    <description>Recent content in Dynamica on Brain Baking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wouter.groeneveld@gmail.com (Wouter Groeneveld)</managingEditor>
    <webMaster>wouter.groeneveld@gmail.com (Wouter Groeneveld)</webMaster>
    <atom:link href="http://www.brainbaking.com/tags/dynamica/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>dynamica</title>
      <link>http://www.brainbaking.com/wiki/code/csharp/dynamica/</link>
      <pubDate>Wed, 05 Nov 2014 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/csharp/dynamica/</guid>
      <description>

&lt;h1 id=&#34;dynamica&#34;&gt;Dynamica&lt;/h1&gt;

&lt;p&gt;Zie ook &lt;a href=&#34;http://www.brainbaking.com/wiki/code/csharp/reflectie/&#34;&gt;code/csharp/reflectie&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;expression-trees-opbouwen&#34;&gt;Expression trees opbouwen&lt;/h3&gt;

&lt;h5 id=&#34;van-een-methodinfo-instantie-naar-een-func&#34;&gt;Van een MethodInfo instantie naar een Func&amp;lt;&amp;gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;            var instanceToMemoize = Activator.CreateInstance&amp;lt;TClassToMemoize&amp;gt;();
            foreach (var method in instanceToMemoize.GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance))
            {
                var parameters ###### method.GetParameters().Select(p &amp;gt; Expression.Constant(&amp;quot;test&amp;quot;));

                var expr = Expression.Lambda(Expression.Call(Expression.Constant(instanceToMemoize), method, parameters)).Compile();
                _Delegates.Add(method.ToString(), expr);
            }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Argumenten stuk klopt nog niet. Refs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/2933221/can-you-get-a-funct-or-similar-from-a-methodinfo-object&#34;&gt;http://stackoverflow.com/questions/2933221/can-you-get-a-funct-or-similar-from-a-methodinfo-object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/11367830/how-to-find-full-name-of-calling-method-c-sharp&#34;&gt;http://stackoverflow.com/questions/11367830/how-to-find-full-name-of-calling-method-c-sharp&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;memoization&#34;&gt;Memoization&lt;/h5&gt;

&lt;p&gt;Ook mogelijk via &lt;code&gt;Func&amp;lt;&amp;gt;&lt;/code&gt; wrappers; zie&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaylee.org/post/2013/04/18/Memoization-and-Immutable-data-in-CSharp-Part-1.aspx&#34;&gt;http://www.jaylee.org/post/2013/04/18/Memoization-and-Immutable-data-in-CSharp-Part-1.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaylee.org/post/2013/04/22/Immutable-Data-and-Memoization-in-CSharp-Part-2.aspx&#34;&gt;http://www.jaylee.org/post/2013/04/22/Immutable-Data-and-Memoization-in-CSharp-Part-2.aspx&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Dit is een extension die 2 type arguments aanvaard:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        public static Func&amp;lt;TArg1, TArg2, TResult&amp;gt; AsMemoized&amp;lt;TArg1, TArg2, TResult&amp;gt;(this Func&amp;lt;TArg1, TArg2, TResult&amp;gt; func)
        {
            var values = new Dictionary&amp;lt;MemoizedKey&amp;lt;TArg1, TArg2&amp;gt;, TResult&amp;gt;();
            return (arg1, arg2) =&amp;gt; MemoizedValue(func, arg1, arg2, values);
        }

        public static Func&amp;lt;TArg, TResult&amp;gt; AsMemoized&amp;lt;TArg, TResult&amp;gt;(this Func&amp;lt;TArg, TResult&amp;gt; funcArg)
        {
            Func&amp;lt;TArg, object, TResult&amp;gt; func ###### (arg1, arg2) &amp;gt; funcArg(arg1);
            var values = new Dictionary&amp;lt;MemoizedKey&amp;lt;TArg, object&amp;gt;, TResult&amp;gt;();
            return (arg) =&amp;gt; MemoizedValue(func, arg, null, values);
        }
        private static TResult MemoizedValue&amp;lt;TArg1, TArg2, TResult&amp;gt;(Func&amp;lt;TArg1, TArg2, TResult&amp;gt; func, TArg1 arg1, TArg2 arg2, Dictionary&amp;lt;MemoizedKey&amp;lt;TArg1, TArg2&amp;gt;, TResult&amp;gt; values)
        {
            TResult value;

            var memoizedKey = new MemoizedKey&amp;lt;TArg1, TArg2&amp;gt;(arg1, arg2);
            if (!values.TryGetValue(memoizedKey, out value))
            {
                value ###### values[memoizedKey]  func(memoizedKey.Arg1, memoizedKey.Arg2);
            }

            return value;
        }

        private class MemoizedKey&amp;lt;TArg1, TArg2&amp;gt;
        {
            public MemoizedKey(TArg1 arg1, TArg2 arg2)
            {
                Arg1 = arg1;
                Arg2 = arg2;
            }

            public TArg1 Arg1 { get; private set; }

            public TArg2 Arg2 { get; private set; }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != this.GetType()) return false;
                return Equals((MemoizedKey&amp;lt;TArg1, TArg2&amp;gt;)obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    return (EqualityComparer&amp;lt;TArg1&amp;gt;.Default.GetHashCode(Arg1) * 397) ^ EqualityComparer&amp;lt;TArg2&amp;gt;.Default.GetHashCode(Arg2);
                }
            }

            private bool Equals(MemoizedKey&amp;lt;TArg1, TArg2&amp;gt; other)
            {
                return EqualityComparer&amp;lt;TArg1&amp;gt;.Default.Equals(Arg1, other.Arg1) &amp;amp;&amp;amp; EqualityComparer&amp;lt;TArg2&amp;gt;.Default.Equals(Arg2, other.Arg2);
            }
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Equals is nodig voor de &lt;code&gt;Dictionary&lt;/code&gt; (generated).&lt;/p&gt;

&lt;h3 id=&#34;aspect-oriented-programming&#34;&gt;Aspect Oriented Programming&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;PostSharp&lt;/strong&gt;: &lt;a href=&#34;http:*www.postsharp.net&#34;&gt;http:*www.postsharp.net&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;transacties-wiren&#34;&gt;Transacties wiren&lt;/h4&gt;

&lt;p&gt;Zie &lt;a href=&#34;http://www.brainbaking.com/wiki/code/csharp/persistence/&#34;&gt;code/csharp/persistence&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;aspects-applyen-op-assembly-level&#34;&gt;Aspects applyen op assembly level&lt;/h4&gt;

&lt;p&gt;Q: Ik wil AOP toepassen voor alle klassen (&amp;amp; [publieke] methods) in een bepaald project (DLL)&lt;br/&gt;&lt;br/&gt;
A: Gebruik &lt;a href=&#34;http://www.postsharp.net/aspects/multicasting&#34;&gt;Multicasting aspects&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Bijvoorbeeld, om exceptions overal op te vangen, en dan door te delegeren, evt screenshot van de app te nemen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: ScenarioTests.ScenarioExceptionHandler]

namespace ScenarioTests
{
    [Serializable]
    [ScenarioExceptionHandler(AttributeExclude = true)]
    public class ScenarioExceptionHandler : OnMethodBoundaryAspect
    {
        public override void OnException(MethodExecutionArgs args)
        {
            WebDriverExceptionHandler.Handle(args.Exception);
            base.OnException(args);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De eerste regel, &lt;code&gt;[assembly:]&lt;/code&gt; is van belang, zie documentatie. Je kan ook verder filteren by visibility etc, zoals in &lt;a href=&#34;http://www.brainbaking.com/wiki/code/java/dynamica/aspectj/&#34;&gt;Spring AOP/AspectJ&lt;/a&gt; de strings in XML gedfiniëerd zijn.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>aspectj</title>
      <link>http://www.brainbaking.com/wiki/code/java/dynamica/aspectj/</link>
      <pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/java/dynamica/aspectj/</guid>
      <description>

&lt;h1 id=&#34;loadtime-weaving-met-aspectj&#34;&gt;Loadtime weaving met aspectJ&lt;/h1&gt;

&lt;h2 id=&#34;spring-weaving&#34;&gt;Spring weaving&lt;/h2&gt;

&lt;p&gt;Zie &lt;strong&gt;demo projectje&lt;/strong&gt;: &lt;img style=&#39;&#39; src=&#39;http://www.brainbaking.com/img//code/java/dynamica/weaving-test.zip|&#39;&gt;&lt;/p&gt;

&lt;p&gt;❗ Vanaf versie 3.0 moet &lt;code&gt;spring-instrument&lt;/code&gt; in plaats van &lt;code&gt;spring-agent&lt;/code&gt; gebruikt worden! (bestaat niet meer)&lt;/p&gt;

&lt;p&gt;Zie &lt;a href=&#34;http://static.springsource.org/spring/docs/3.1.0.RELEASE/reference/htmlsingle/#aop&#34;&gt;http://static.springsource.org/spring/docs/3.1.0.RELEASE/reference/htmlsingle/#aop&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Weavers:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;aspectj jar&lt;/strong&gt; &lt;code&gt;-javaagent:C:&amp;lt;br/&amp;gt;dvl.home&amp;lt;br/&amp;gt;env&amp;lt;br/&amp;gt;aspectj&amp;lt;br/&amp;gt;aspectjweaver-1.6.11.jar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spring-instrument jar&lt;/strong&gt; &lt;code&gt;-javaagent:C:/dvl.home/prj/comeet/tools/spring-instrument-3.1.0.RELEASE.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;wat-heb-je-nodig-om-loadtime-weaving-te-laten-werken&#34;&gt;Wat heb je nodig om loadtime weaving te laten werken&lt;/h4&gt;

&lt;h5 id=&#34;applicationcontext-xml&#34;&gt;applicationContext.xml&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;met spring-configured (zelfde als &lt;code&gt;org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect&lt;/code&gt; bean, zie &lt;a href=&#34;http://static.springsource.org/spring/docs/3.0.0.RC2/reference/html/ch07s08.html&#34;&gt;spring docs&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;met &lt;code&gt;load-time-weaver&lt;/code&gt; op&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version######&amp;quot;1.0&amp;quot; encoding&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http:*www.springframework.org/schema/beans http:*www.springframework.org/schema/beans/spring-beans-3.0.xsd
                           http:*www.springframework.org/schema/context http:*www.springframework.org/schema/context/spring-context-3.0.xsd&amp;quot;&amp;gt;

    &amp;lt;context:spring-configured/&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;be.test&amp;quot;/&amp;gt;    
    &amp;lt;context:load-time-weaver/&amp;gt;    
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;juiste-manier-van-opzetten-beans&#34;&gt;juiste manier van opzetten beans&lt;/h5&gt;

&lt;p&gt;-&amp;gt; Een bean die &lt;code&gt;@Component&lt;/code&gt; annotated is waar een andere bean die &lt;code&gt;@Configurable&lt;/code&gt; ge-&lt;code&gt;new&lt;/code&gt;t wordt, die via &lt;code&gt;@Autowired&lt;/code&gt; injecties bevat&lt;/p&gt;

&lt;p&gt;bijvroobeeld:&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;code&gt;SomeBean&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class SomeBean {

	private final SomeBeanToInject someBeanToInject;

	@Autowired
	public SomeBean(SomeBeanToInject someBeanToInject) {
		System.out.println(&amp;quot;creating some bean, got injected: &amp;quot; + someBeanToInject);
		this.someBeanToInject = someBeanToInject;
	}

	public OtherBean createOtherBean() {
		return new OtherBean();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt; &lt;code&gt;OtherBean&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configurable
public class OtherBean {

	private SomeBeanToDynamicallyInject someBeanToDynamicallyInject;

	@Autowired
	public void setSomeBeanToDynamicallyInject(SomeBeanToDynamicallyInject someBeanToDynamicallyInject) {
		System.out.println(&amp;quot;Setting some dynamically injected bean! : &amp;quot; + someBeanToDynamicallyInject);
		this.someBeanToDynamicallyInject = someBeanToDynamicallyInject;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt; &lt;code&gt;SomeBeanToDynamicallyInject&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class SomeBeanToDynamicallyInject {
	public String message = &amp;quot;dynamically injected&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;aspectj-en-junit-testing&#34;&gt;AspectJ en Junit testing&lt;/h4&gt;

&lt;p&gt;De annotatie &lt;code&gt;@EnableLoadTimeWeaving&lt;/code&gt; heb je &lt;strong&gt;NIET&lt;/strong&gt; nodig. Het is ook niet nodig om java config klasse te verwijzen, de context xml pikt dit met component scanning op!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ContextConfiguration(locations = { &amp;quot;../../applicationContext.xml&amp;quot; })
@RunWith(SpringJUnit4ClassRunner.class)
public class SomeBeanTest {

	@Autowired
	private SomeBean someBean;

	@Test
	public void someBeanIsDynamicallyInjected() {
		Assert.assertTrue(someBean.createOtherBean().isDynamicallyInjected());
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;❗ &lt;strong&gt;Unit- en Integratietesten opsplitsen in andere source folders&lt;/strong&gt;! Waarom?&lt;br/&gt;&lt;br/&gt;
Omdat, ééns als een class file ingeladen is door de JVM, deze in het geheugen blijft zitten, en de volgende keer dat een andere test binnen dezelfde suite deze wilt gebruiken en verwacht dat die enhanched is (dus &lt;code&gt;@Autowired&lt;/code&gt; geïnjecteerd), dit niet zo is, omdat een vorige gewone unit test hier een &lt;code&gt;new&lt;/code&gt; van gedaan heeft en dit reeds in het geheugen steekt.&lt;/p&gt;

&lt;p&gt;Is hier een oplossing voor? &lt;code&gt;ClassLoader&lt;/code&gt; cache clearen op een of andere manier? Zie &lt;a href=&#34;http://members.iinet.net.au/~macneall/Java/ClassReloading.html&#34;&gt;http://members.iinet.net.au/~macneall/Java/ClassReloading.html&lt;/a&gt; -&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Java classes themselves are dumped from memory when the classloader that loaded them is garbage collected. So the way to dynamically reload a class is to make sure that you control the classloader for that class. So when, all the references to instances of that class are gone, and you null the classloader itself, the runtime should collect the class itself. Then, next time an object of that class is used, it needs to be loaded again.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Probleem doet zich voor met &lt;code&gt;mvn clean install&lt;/code&gt; maar soms niet in eclipse??&lt;/p&gt;

&lt;h2 id=&#34;aop-xml-configuratie&#34;&gt;aop.xml configuratie&lt;/h2&gt;

&lt;p&gt;Deze wordt blijkbaar gebruikt om te bepalen wat er precies gewoven moet worden - als die er NIET is gaat hij by default alles weaven en een warning tonen in de console log:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[AppClassLoader@17943a4] warning javax.* types are not being woven because the weaver option &#39;-Xset:weaveJavaxPackages=true&#39; has not been specified
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File moet in &lt;strong&gt;src/main/resources/META-INF/aop.xml&lt;/strong&gt; staan (op classpath). Content bvb:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;

&amp;lt;aspectj&amp;gt;
    &amp;lt;aspects&amp;gt;
        &amp;lt;weaver options=&amp;quot;-Xlint:ignore -nowarn&amp;quot;&amp;gt;
            &amp;lt;include within=&amp;quot;@org.springframework.beans.factory.annotation.Configurable be.bla.blie..*&amp;quot; /&amp;gt;
        &amp;lt;/weaver&amp;gt;
    &amp;lt;/aspects&amp;gt;
&amp;lt;/aspectj&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;options&#34;&gt;options&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-Xlint:ignore -nowarn&lt;/code&gt; negeert alle warnings dat bepaalde zaken niet gewoven kunnen worden&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-verbose&lt;/code&gt; print meer debuginfo&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-showWeaveInfo&lt;/code&gt; print wat wanneer gewoven wordt.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>dynamica</title>
      <link>http://www.brainbaking.com/wiki/code/java/dynamica/</link>
      <pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/java/dynamica/</guid>
      <description>

&lt;h1 id=&#34;dynamica&#34;&gt;Dynamica&lt;/h1&gt;

&lt;p&gt;Hier zitten stukjes code om java meer dynamiek te geven (voorzover dat mogelijk is&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Veel collectie gerelateerde dingen (&lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; etc) is reeds geïmplementeerd: &lt;a href=&#34;http://code.google.com/p/guava-libraries/&#34;&gt;http://code.google.com/p/guava-libraries/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;reduce-met-optellen&#34;&gt;Reduce met optellen&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CollectionUtil {

	public static interface EnkelvoudigeTeller&amp;lt;TellerType&amp;gt; {
		boolean magMeegeteldWorden(TellerType object);
	}

	public static interface MeervoudigeTeller&amp;lt;TellerType&amp;gt; {
		int geefAantalMeegeteld(TellerType object);
	}

	public static &amp;lt;TellerType&amp;gt; int tel(Collection&amp;lt;TellerType&amp;gt; objecten, MeervoudigeTeller&amp;lt;TellerType&amp;gt; teller) {
		int geteld = 0;
		for (TellerType object : objecten) {
			geteld += teller.geefAantalMeegeteld(object);
		}
		return geteld;
	}

	public static &amp;lt;TellerType&amp;gt; int tel(Collection&amp;lt;TellerType&amp;gt; objecten, final EnkelvoudigeTeller&amp;lt;TellerType&amp;gt; teller) {
		return tel(objecten, new MeervoudigeTeller&amp;lt;TellerType&amp;gt;() {

			@Override
			public int geefAantalMeegeteld(TellerType object) {
				return teller.magMeegeteldWorden(object) ? 1 : 0;
			}
		});
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>innerclasses</title>
      <link>http://www.brainbaking.com/wiki/code/java/dynamica/innerclasses/</link>
      <pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/java/dynamica/innerclasses/</guid>
      <description>

&lt;h1 id=&#34;code-java-dynamica-innerclasses&#34;&gt;code:java:dynamica &amp;gt;&amp;gt; Innerclasses&lt;/h1&gt;

&lt;p&gt;Java is geen dynamische taal maar je kan wel gebruik maken van een aantal handige trucjes om duplicatie te vermijden.
Bijvoorbeeld om &lt;strong&gt;state bij te houden&lt;/strong&gt; en de implementatie zelf in een &lt;strong&gt;inner klasse&lt;/strong&gt; te voorzien:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private interface CrmEndpointWorker {
        void call(Holder&amp;lt;Status&amp;gt; status, Holder&amp;lt;String&amp;gt; result);
    }

    public CrmImportGatewayAction forCreation() {
        return new CrmImportGatewayAction(Action.CREATE);
    }

    public CrmImportGatewayAction forUpdating() {
        return new CrmImportGatewayAction(Action.UPDATE);
    }

    public CrmImportGatewayAction forDeletion() {
        return new CrmImportGatewayAction(Action.DELETE);
    }

    public CrmImportGatewayAction forDeactivating() {
        return new CrmImportGatewayAction(Action.DEACTIVATE);
    }

    public class CrmImportGatewayAction {

        private final Action actionType;

        public CrmImportGatewayAction(Action actionType) {
            this.actionType = actionType;
        }

        private CrmEndpointWorker accessdeviceAction(final List&amp;lt;Accessdevice&amp;gt; devices) {
            return new CrmEndpointWorker() {

                @Override
                public void call(Holder&amp;lt;Status&amp;gt; status, Holder&amp;lt;String&amp;gt; result) {
                    getEndpoint().accessdeviceAction(actionType, new CrmConverter().convertDevices(devices), status, result);
                }
            };
        }

        public String sendAccessdevices(List&amp;lt;Accessdevice&amp;gt; devices) {
            return callCrmEndpoint(accessdeviceAction(devices));
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wat is hier cool aan?
In plaats van 4 verschillende methods te voorzien op deze klasse:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;voor creation&lt;/li&gt;
&lt;li&gt;voor deletion&lt;/li&gt;
&lt;li&gt;voor updating&lt;/li&gt;
&lt;li&gt;voor activating&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kan je dit nu zo doen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;service.forCreation().sendAccessdevices();
service.forDeletion().sendAccessdevices();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En de &lt;code&gt;Enum actionType&lt;/code&gt; is toegankelijk binnen die inner klasse en wordt zo mee doorgegeven naar in dit geval de SOAP Endpoint call.&lt;/p&gt;

&lt;p&gt;Prachtig, toch?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>listmerger</title>
      <link>http://www.brainbaking.com/wiki/code/java/dynamica/listmerger/</link>
      <pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/java/dynamica/listmerger/</guid>
      <description>

&lt;h1 id=&#34;code-java-dynamica-listmerger&#34;&gt;code:java:dynamica &amp;gt;&amp;gt; Listmerger&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ListMerger&amp;lt;ItemType, ItemTypeAfterConversion&amp;gt; {

    private final Function&amp;lt;ItemType, ItemTypeAfterConversion&amp;gt; itemConverterFn;

    public ListMerger() {
        this.itemConverterFn = identityFn();
    }

    public ListMerger(Function&amp;lt;ItemType, ItemTypeAfterConversion&amp;gt; itemConverterFn) {
        this.itemConverterFn = itemConverterFn;
    }

    private Function&amp;lt;ItemType, ItemTypeAfterConversion&amp;gt; identityFn() {
        return new Function&amp;lt;ItemType, ItemTypeAfterConversion&amp;gt;() {

            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
            @Override
            public ItemTypeAfterConversion apply(ItemType input) {
                return (ItemTypeAfterConversion) input;
            }
        };
    }

    public final void mergeLists(List&amp;lt;? extends ItemType&amp;gt; oldList, List&amp;lt;? extends ItemType&amp;gt; newList, ListMergable&amp;lt;ItemType&amp;gt; mergable) {
        List&amp;lt;ItemTypeAfterConversion&amp;gt; oldTransformed = new ArrayList&amp;lt;ItemTypeAfterConversion&amp;gt;(transform(oldList, itemConverterFn));
        List&amp;lt;ItemTypeAfterConversion&amp;gt; newTransformed = new ArrayList&amp;lt;ItemTypeAfterConversion&amp;gt;(transform(newList, itemConverterFn));

        for (ItemType item : new ArrayList&amp;lt;ItemType&amp;gt;(oldList)) {
            if (!newTransformed.contains(itemConverterFn.apply(item))) {
                mergable.itemHasBeenRemoved(item);
            } else {
                mergable.itemHasBeenChangedInOldList(item);
            }
        }
        for (ItemType item : new ArrayList&amp;lt;ItemType&amp;gt;(newList)) {
            if (!oldTransformed.contains(itemConverterFn.apply(item))) {
                mergable.itemHasBeenAdded(item);
            } else {
                mergable.itemHasBeenChangedInNewList(item);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En de test:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ListMergerTest {

    private AtomicInteger integer = null;
    private AtomicInteger amount = null;

    @Before
    public void setUp() {
        this.integer = new AtomicInteger();
        this.amount = new AtomicInteger(0);
    }

    @Test
    public void noItemsChanged() {
        new ListMerger&amp;lt;Integer, Long&amp;gt;(intToLongFn()).mergeLists(Lists.newArrayList(1, 3), Lists.newArrayList(1, 3), new ListMergable&amp;lt;Integer&amp;gt;() {

            @Override
            public void itemHasBeenRemoved(Integer item) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void itemHasBeenChangedInOldList(Integer item) {
                amount.set(amount.get() + 1);
            }

            @Override
            public void itemHasBeenChangedInNewList(Integer item) {
            }

            @Override
            public void itemHasBeenAdded(Integer item) {
                throw new UnsupportedOperationException();
            }
        });

        assertThat(amount.get()).isEqualTo(2);
    }

    @Test
    public void itemHasBeenAddedUsingIdentity() {
        new ListMerger&amp;lt;Integer, Integer&amp;gt;().mergeLists(Lists.newArrayList(1, 3), Lists.newArrayList(1, 2, 3), new ListMergable&amp;lt;Integer&amp;gt;() {

            @Override
            public void itemHasBeenRemoved(Integer item) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void itemHasBeenChangedInOldList(Integer item) {
            }

            @Override
            public void itemHasBeenChangedInNewList(Integer item) {
            }

            @Override
            public void itemHasBeenAdded(Integer item) {
                integer.set(item);
                amount.set(amount.get() + 1);
            }
        });

        assertThat(amount.get()).isEqualTo(1);
        assertThat(integer.get()).isEqualTo(2);
    }

    @Test
    public void itemHasBeenAdded() {
        new ListMerger&amp;lt;Integer, Long&amp;gt;(intToLongFn()).mergeLists(Lists.newArrayList(1, 3), Lists.newArrayList(1, 2, 3), new ListMergable&amp;lt;Integer&amp;gt;() {

            @Override
            public void itemHasBeenRemoved(Integer item) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void itemHasBeenChangedInOldList(Integer item) {
            }

            @Override
            public void itemHasBeenChangedInNewList(Integer item) {
            }

            @Override
            public void itemHasBeenAdded(Integer item) {
                integer.set(item);
                amount.set(amount.get() + 1);
            }
        });

        assertThat(amount.get()).isEqualTo(1);
        assertThat(integer.get()).isEqualTo(2);
    }

    @Test
    public void itemHasBeenRemovedUsingIdentity() {
        new ListMerger&amp;lt;Integer, Integer&amp;gt;().mergeLists(Lists.newArrayList(1, 3), Lists.newArrayList(1), new ListMergable&amp;lt;Integer&amp;gt;() {

            @Override
            public void itemHasBeenRemoved(Integer item) {
                integer.set(item);
                amount.set(amount.get() + 1);
            }

            @Override
            public void itemHasBeenChangedInOldList(Integer item) {
            }

            @Override
            public void itemHasBeenChangedInNewList(Integer item) {
            }

            @Override
            public void itemHasBeenAdded(Integer item) {
                throw new UnsupportedOperationException();
            }
        });

        assertThat(amount.get()).isEqualTo(1);
        assertThat(integer.get()).isEqualTo(3);
    }

    @Test
    public void itemHasBeenRemoved() {
        new ListMerger&amp;lt;Integer, Long&amp;gt;(intToLongFn()).mergeLists(Lists.newArrayList(1, 2, 3), Lists.newArrayList(1, 3), new ListMergable&amp;lt;Integer&amp;gt;() {

            @Override
            public void itemHasBeenRemoved(Integer item) {
                integer.set(item);
                amount.set(amount.get() + 1);
            }

            @Override
            public void itemHasBeenChangedInOldList(Integer item) {
            }

            @Override
            public void itemHasBeenChangedInNewList(Integer item) {
            }

            @Override
            public void itemHasBeenAdded(Integer item) {
                throw new UnsupportedOperationException();
            }
        });

        assertThat(amount.get()).isEqualTo(1);
        assertThat(integer.get()).isEqualTo(2);
    }

    private Function&amp;lt;Integer, Long&amp;gt; intToLongFn() {
        return new Function&amp;lt;Integer, Long&amp;gt;() {

            @Override
            public Long apply(Integer input) {
                return new Long(input);
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voorbeeld van gebruik:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        final List&amp;lt;Location&amp;gt; removedLocations = new ArrayList&amp;lt;Location&amp;gt;();
        final List&amp;lt;Location&amp;gt; addedLocations = new ArrayList&amp;lt;Location&amp;gt;();
        new ListMerger&amp;lt;Location, Location&amp;gt;().mergeLists(oldLocations, carpark.getLocations(), new ListMergable&amp;lt;Location&amp;gt;() {

            @Override
            public void itemHasBeenAdded(Location item) {
                addedLocations.add(item);
            }

            @Override
            public void itemHasBeenRemoved(Location item) {
                removedLocations.add(item);
            }

            @Override
            public void itemHasBeenChangedInOldList(Location item) {
            }

            @Override
            public void itemHasBeenChangedInNewList(Location item) {
            }

        });
        if (!removedLocations.isEmpty()) {
            crmImportGatewayService.forDeletion().sendCarparkLocations(carpark, removedLocations);
        }
        if (!addedLocations.isEmpty()) {
            crmImportGatewayService.forCreation().sendCarparkLocations(carpark, addedLocations);
        }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>