<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sql on Brain Baking</title>
    <link>http://www.brainbaking.com/tags/sql/index.xml</link>
    <description>Recent content in Sql on Brain Baking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wouter.groeneveld@gmail.com (Wouter Groeneveld)</managingEditor>
    <webMaster>wouter.groeneveld@gmail.com (Wouter Groeneveld)</webMaster>
    <atom:link href="http://www.brainbaking.com/tags/sql/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Integration Testing with SQLite</title>
      <link>http://www.brainbaking.com/post/integration-testing-sqlite/</link>
      <pubDate>Mon, 04 Nov 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/post/integration-testing-sqlite/</guid>
      <description>

&lt;p&gt;This article is based on the notes I&amp;rsquo;ve collected on &lt;a href=&#34;http://brainbaking.com/wiki/code/db/sqlite&#34;&gt;My Wiki&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;On previous projects I&amp;rsquo;ve worked on, development PCs came with a local version of the database scheme. Each DB change also got rolled out to those computers, which enabled us developers to fool around without breaking anything on the development (or test) environment. This is another step closer to happiness, at least for our proxy customers who didn&amp;rsquo;t have to reinsert their test data every time we flushed something from a table. Sometimes though, there&amp;rsquo;s some lame excuse for not having a local database installed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We have a lot of stored procedures and it&amp;rsquo;s too hard to duplicate them locally&lt;/li&gt;
&lt;li&gt;We worked like this for years, why would I want a local DB?&lt;/li&gt;
&lt;li&gt;But then my data is out of sync!&lt;/li&gt;
&lt;li&gt;I tried doing that but my manager says I should focus on delivering content&lt;/li&gt;
&lt;li&gt;Blah blah blah&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Installing an Oracle XE runtime on your machine might include working around some issues which can take up some time but it&amp;rsquo;s time well invested, compared to multiple developers connecting to one shared database. In any case, there&amp;rsquo;s another possibility: an &lt;strong&gt;in-memory database&lt;/strong&gt;, such as &lt;a href=&#34;http://www.sqlite.org/&#34;&gt;SQLite&lt;/a&gt;. This does still require you to keep the upgrade scripts synced, but also enables you to get rid of a lot of annoying things like &lt;em&gt;foreign key constraints&lt;/em&gt; for testing purposes.&lt;/p&gt;

&lt;h3 id=&#34;integrating-sqlite-with-net&#34;&gt;Integrating SQLite with .NET&lt;/h3&gt;

&lt;p&gt;Simply use &lt;a href=&#34;http://system.data.sqlite.org/index.html/doc/trunk/www/index.wiki&#34;&gt;System.data.SQLite&lt;/a&gt;. For each OleDb object, there&amp;rsquo;s an equivalent SQLite one in the correct namespace. The only problem is, some of them don&amp;rsquo;t share an abstract object so you&amp;rsquo;ll have to come up with an anti-corruption layer yourself. Create a connection using this connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private SQLiteConnection SqLiteDbConnection()
    {
        return new SQLiteConnection()
            {
                ConnectionString = &amp;quot;Data Source=:memory:;Version=3;New=True;DateTimeFormat=Ticks&amp;quot;,
                Flags = SQLiteConnectionFlags.LogAll
            };
    }

    public void SetupDb()
    {
        using (var connection = SqLiteDbConnection())
        {
            connection.Open();
            var transaction = connection.BeginTransaction();
            var sqLiteCommand = new SQLiteCommand()
                {
                    Connection = (SQLiteConnection) connection,
                    CommandType = CommandType.Text,
                    CommandText = GetSchemaCreateSql()
                };
            sqLiteCommand.ExecuteNonQuery();
            transaction.Commit();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to pay attention to the &lt;code&gt;DateTimeFormat&lt;/code&gt; substring in the connection string as SQLite is &amp;ldquo;dynamically typed&amp;rdquo;, compared to Oracle. This means it stores dates exactly the same as chars, otherwise you might encounter an error like &lt;code&gt;&amp;quot;string was not recognized as a valid DateTime&amp;quot;&lt;/code&gt; when executing a select statement.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Watch out with closing the DB Connection&lt;/strong&gt; using an in-memory DB; as this completely resets everything. As soon as you open a connection, you can execute create table commands (read your stored DDL file and do it in bulk).
Your anti-corruption layer between the abstract DB Connection and SQLite/OleDB should expose a few methods. It should be able to query (with or without parameters or providing a &lt;code&gt;DbCommand&lt;/code&gt;) and possibly stored procedures. This is what I&amp;rsquo;ve come up with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IdbConnection
{
    object QueryProcedure(string procedure, IDictionary&amp;lt;string, object&amp;gt; parameters, string outputParameter);

    DbParameter CreateParameter(string field, object value);

    DbCommand CreateCommand(string query);

    DataSet Query(DbCommand command);

    DataSet Query(string query);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on the implementation, it&amp;rsquo;ll return an &lt;code&gt;SQLiteCommand&lt;/code&gt; or an &lt;code&gt;OleDbCommand&lt;/code&gt; instance.&lt;/p&gt;

&lt;h3 id=&#34;creating-integration-tests-using-record-objects&#34;&gt;Creating integration tests, using Record objects&lt;/h3&gt;

&lt;p&gt;To be able to quickly insert junk in an in-memory table, I came up with a simple object-table mapping which uses reflection to scan for each property of an object, and map that property to a column in a table. Normally you would simply use your domain objects and issue a &lt;code&gt;save()&lt;/code&gt; or &lt;code&gt;persist()&lt;/code&gt; call using for instance &lt;code&gt;NHibernate&lt;/code&gt; but we didn&amp;rsquo;t have anything like that and this was easy to setup.&lt;/p&gt;

&lt;p&gt;Create an object for each table in your unit test project, extending &lt;code&gt;DatabaseInsertable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class DatabaseInsertable
{
    protected abstract string GetTable();

    public override string ToString()
    {
        var fieldDict = FieldDictionary();
        var fields = &amp;quot;(&amp;quot; + string.Join(&amp;quot;,&amp;quot;, fieldDict.Keys) + &amp;quot;)&amp;quot;;
        var values = &amp;quot;(&amp;quot; + string.Join(&amp;quot;,&amp;quot;, fieldDict.Values) + &amp;quot;)&amp;quot;;

        return &amp;quot;insert into &amp;quot; + GetTable() + fields + &amp;quot; values &amp;quot; + values;
    }

    public void Save()
    {
        DbConnection.Instance.CreateCommand(ToString()).ExecuteNonQuery();
    }

    private Dictionary&amp;lt;string, string&amp;gt; FieldDictionary()
    {
        var dictionary = new Dictionary&amp;lt;string, string&amp;gt;();

        foreach (var info in this.GetType().GetFields())
        {
            if (info.GetValue(this) != null)
            {
                dictionary.Add(info.Name, &amp;quot;&#39;&amp;quot; + info.GetValue(this).ToString() + &amp;quot;&#39;&amp;quot;);
            }
        }

        return dictionary;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;internal class UnitRecord : DatabaseInsertable
{
    public string creator;
    public string guid;

    protected override string GetTable()
    {
        return &amp;quot;UNIT&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can simply issue &lt;code&gt;new UnitRecord() { creator = &amp;quot;bla&amp;quot;; guid = &amp;quot;lala&amp;quot;; }.Save();&lt;/code&gt; and it&amp;rsquo;s saved into the unit table, yay!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unit Testing Stored Procedures</title>
      <link>http://www.brainbaking.com/post/unit-testing-stored-procedures/</link>
      <pubDate>Thu, 10 Oct 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/post/unit-testing-stored-procedures/</guid>
      <description>

&lt;p&gt;This article is based on the notes I&amp;rsquo;ve collected on &lt;a href=&#34;http://brainbaking.com/wiki/code/db/sql&#34;&gt;My Wiki&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Test Driven Development (or TDD), it&amp;rsquo;s one of those buzz words which usuallly appear in the same sentence with &amp;ldquo;scrum&amp;rdquo; or &amp;ldquo;XP&amp;rdquo;. But in practice, I&amp;rsquo;ve seen few people actually applying it all the way through. What do I mean by that? You&amp;rsquo;re probably very familiar with, say Java or .NET, and you know how to write unit tests in that language using your beloved IDE. That&amp;rsquo;s a good start, right. Maybe you might even do it the test-first way: writing a failing test (letting it fail for the right reason), writing the implementation and maybe some refactoring. Red, Green, Refactor.&lt;/p&gt;

&lt;p&gt;But what do you do when you need to step out of your language comfort zone to write some Javascript on the client side? Do you copypaste stuff or try to apply the same techniques as you&amp;rsquo;re used to? You might have heard from test frameworks like &lt;a href=&#34;http://pivotal.github.io/jasmine/&#34;&gt;Jasmine&lt;/a&gt; and use these. Also good for you! Client side development is very popular, but what about SQL? Do you write tests for stored procedures? I thought so. There are plenty of frameworks available to help you in doing this, for instance &lt;a href=&#34;http://docs.oracle.com/cd/E15846_01/doc.21/e15222/unit_testing.htm&#34;&gt;SQL Developer&lt;/a&gt; which I used because it&amp;rsquo;s already installed on every developer&amp;rsquo;s PC and has a &amp;ldquo;friendly&amp;rdquo; interface.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://brainbaking.com/wiki/_media/code/db/unittest_sqldev.png&#34; alt=&#34;sql dev unit test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once you create a &amp;ldquo;test repository&amp;rdquo;, SQL Developer will create test tables to store it&amp;rsquo;s unit test descriptions and results, prefixed by &amp;ldquo;UT_&amp;ldquo;. You can specify whether you&amp;rsquo;d like to create a new scheme for it or not. When creating a new test, the tool asks you a couple of questions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What do you want to insert or execute before the test? (Setup phase)&lt;/li&gt;
&lt;li&gt;What stored procedure do you want to execute? (Execute system under test phase)&lt;/li&gt;
&lt;li&gt;What should the result of the procedure be, or execute a query and check it&amp;rsquo;s results? (Verify phase)&lt;/li&gt;
&lt;li&gt;What do you want to insert or execute after the test? (Teardown phase)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can reuse the parts to be executed in the different phases for another unit test, yay! This data will also be stored in the predefined tables.&lt;/p&gt;

&lt;h3 id=&#34;but-what-about-existing-data-when-inserting-new-stuff&#34;&gt;But what about existing data when inserting new stuff?&lt;/h3&gt;

&lt;p&gt;use this as teardown:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ROLLBACK;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;but-how-do-you-execute-a-stored-procedure-with-in-out-ref-cursor-arguments&#34;&gt;But how do you execute a stored procedure with IN/OUT REF CURSOR arguments?&lt;/h3&gt;

&lt;p&gt;SQL Developer has some trouble executing that, indeed. In this case, we use a little trick:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create a dummy stored procedure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create or replace 
PROCEDURE UT_DUMMY AS 
BEGIN
  NULL;
END UT_DUMMY;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Execute the dummy procedure in the SUT phase.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use the verify phase to call the actual to test procedure yourself, and do your verification stuff yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE     
  P_USERID NUMBER;     
  MY_P_CURSOR SCHEMA.PACKAGE.Cursor;     
  cursor_element MY_P_CURSOR.SCHEMA.CursorType;     
  found boolean;     
BEGIN     
  P_USERID := 11;     
  found := false;     

  PACKAGE.MYPROCEDURE(     
    P_USERID =&amp;gt; P_USERID,     
    P_CURSOR =&amp;gt; MY_P_CURSOR     
  );     

 WHILE TRUE LOOP     
    FETCH MY_P_CURSOR INTO cursor_element;     
    EXIT WHEN MY_P_CURSOR%NOTFOUND;     
    IF cursor_element.columntocheck = &#39;My value&#39; THEN     
      found  := true;     
    END IF;     
  END LOOP;     

 IF found = false THEN     
   raise_application_error(-20000, &#39;Your error message in here!&#39;);     
 END IF;     

END; 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;okay-but-what-about-integrating-the-exeuction-of-these-tests-in-my-build-system&#34;&gt;Okay but what about integrating the exeuction of these tests in my build system?&lt;/h3&gt;

&lt;p&gt;You can use the commandline utility provided by SQL Developer to execute a test or a suite:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ututil -run -suite -name [name] -repo [repo] -db [db] -log 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s very interesting to dynamically import and export tests using &amp;ldquo;-imp&amp;rdquo; and &amp;ldquo;-exp&amp;rdquo;, and creating one suite using this PL/SQL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SET serveroutput ON;

delete from ut_suite_items;
delete from ut_suite;

DROP SEQUENCE ut_suite_items_seq;
CREATE SEQUENCE ut_suite_items_seq
  MINVALUE 0
  MAXVALUE 999999999999999999999999999
  START WITH 0
  INCREMENT BY 1;

DECLARE
    suiteid VARCHAR2(900) := &#39;ALL&#39;;
    utid VARCHAR2(900);
    cursor tableCursor is SELECT UT_ID FROM UT_TEST;
BEGIN

dbms_output.enable(10000);
DBMS_OUTPUT.PUT_LINE(&#39;Creating one test suite to rule them ALL...&#39;);

insert into ut_suite(ut_sid, coverage, name, created_on, created_by, updated_on, updated_by)
  values(suiteid, 0, suiteid, null, null, null, null);

open tableCursor;
fetch tableCursor into utid;
WHILE (tableCursor%FOUND) LOOP

  insert into ut_suite_items(ut_sid, ut_id, ut_nsid, run_start, run_tear, sequence, created_on, created_by, updated_on, updated_by)
    values (suiteid, utid, null, &#39;Y&#39;, &#39;Y&#39;, ut_suite_items_seq.nextval, null, null, null, null);

  fetch tableCursor into utid;
END LOOP;
close tableCursor;

commit;
DBMS_OUTPUT.PUT_LINE(&#39;SUCCESS - test suite created!&#39;);

END;
/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It creates only one suite called &amp;lsquo;ALL&amp;rsquo; which can then be executed. The commandline utility will output &amp;ldquo;UT_SUCCESS&amp;rdquo; or throw some kind of exception if one of the tests failed.&lt;/p&gt;

&lt;h3 id=&#34;i-still-get-errors-using-ututil-some-connectexception&#34;&gt;I still get errors using ututil, some ConnectException?&lt;/h3&gt;

&lt;p&gt;the utility cannot handle any TNS connections you&amp;rsquo;ve entered in SQL Developer. Change these to regular connection strings and all will be well. Yes it&amp;rsquo;s a huge disadvantage, and yes the connection settings are stored in your locally installed SQL Developer instance, which also kind of sucks. We needed to install SQL developer on the Build integration PC and configure the same connections within it.&lt;/p&gt;

&lt;h3 id=&#34;what-about-versioning-the-tests-are-stored-in-my-db-but-it-doesn-t-evolve-as-quickly-as-the-code-does&#34;&gt;What about versioning? The tests are stored in my DB, but it doesn&amp;rsquo;t evolve as quickly as the code does!&lt;/h3&gt;

&lt;p&gt;Right, that&amp;rsquo;s where the import/export thing comes in. We store the actual unit tests in XML format inside our regular source control system, next to the &amp;ldquo;other&amp;rdquo; unit tests (in this case in .NET). Every time someone writes a unit test using SQL developer, it extracts that test using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ututil -exp -test [name] -file [file] ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which creates an XML file. Executing the tests happen within a wrapper .NET test class, which goes through some steps to setup the DB system correctly:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cleanup all UT_TEST* and UT_SUITE* tables which would contain the acutal tests.&lt;/li&gt;
&lt;li&gt;Loop through all XML files, and impor them one by one (they get inserted into the cleaned tables)&lt;/li&gt;
&lt;li&gt;Generate the &amp;lsquo;ALL&amp;rsquo; unit test suite - see PL/SQL above.&lt;/li&gt;
&lt;li&gt;Execute the test suite using ututil and parse the results from the command line.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That&amp;rsquo;s as far as our imagination and budget goes. We have a stable system which is able to version the XML files - inserting the test data is still dependant on the actual state of the database. One could explore the dynamic creating of tables the stored procedures use, but as our codebase is legacy (read: really really old stuff), we decided not to invest too much time in that.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sql</title>
      <link>http://www.brainbaking.com/wiki/code/db/sql/</link>
      <pubDate>Tue, 03 Sep 2013 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/db/sql/</guid>
      <description>

&lt;h1 id=&#34;code-db-sql&#34;&gt;code:db &amp;gt;&amp;gt; Sql&lt;/h1&gt;

&lt;h2 id=&#34;stored-procedures&#34;&gt;Stored procedures&lt;/h2&gt;

&lt;h3 id=&#34;oproepen&#34;&gt;Oproepen&lt;/h3&gt;

&lt;p&gt;Zie &lt;a href=&#34;http://stackoverflow.com/questions/3991721/run-stored-procedure-in-sql-developer&#34;&gt;http://stackoverflow.com/questions/3991721/run-stored-procedure-in-sql-developer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Gegeven: een procedure &lt;code&gt;GETPERMISSIONSALL&lt;/code&gt; als volgt gedeclareerd:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create or replace 
PROCEDURE &amp;quot;GETPERMISSIONALL&amp;quot; ( v_actCreator in VARCHAR2, v_repGuid in VARCHAR2, v_userid INT, v_retHasPermission out SMALLINT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De laatste parameter is de return waarde (kunnen meerdere dingen zijn dus). Hoe roep ik nu zoiets aan?&lt;/p&gt;

&lt;h4 id=&#34;in-sql-developer&#34;&gt;In SQL Developer&lt;/h4&gt;

&lt;p&gt;Definiëer eerst uw variabelen, om ze daarna eventueel af te drukken -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET serveroutput on;
DECLARE
    v_actCreator VARCHAR2(100);
    v_repGuid VARCHAR2(100);
    v_userid int;
    Output smallint;
BEGIN
    /* Assign values to IN parameters */
    v_actCreator := &#39;19980121164845.106.1 7&#39;;
    v_repGuid := &#39;2466B39EFDA94D5E9249D252FF25C4D6&#39;;
    v_userid := 540;

    /* Call procedure within package, identifying schema if necessary */
    GETPERMISSIONALL(v_actCreator, v_repGuid, v_userid, Output);

    /* Display OUT parameters */
    dbms_output.put_line(&#39;Output: &#39; || Output);
END;
/
-- Display OUT parameters
-- print :Output;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;werken-met-ref-cursor&#34;&gt;Werken met REF CURSOR&lt;/h5&gt;

&lt;p&gt;Probleemstelling:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Uw procedure retourneert een &lt;code&gt;REF CURSOR&lt;/code&gt; als IN en OUT variabele&lt;/li&gt;
&lt;li&gt;Je wil over deze gaan loopen en ergens een resultaat afdrukken of vergelijken&lt;/li&gt;
&lt;li&gt;openen van een &lt;code&gt;REF CURSOR&lt;/code&gt; gaat niet.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Gebruik in een &lt;code&gt;LOOP&lt;/code&gt; dadelijk &lt;code&gt;FETCH&lt;/code&gt; &lt;code&gt;INTO&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET serveroutput ON;
DECLARE
  P_USERID NUMBER;
  MY_P_CURSOR C2MV5_DEV.PKG_WFSEC.Validation_Send_Item_Cursor;
  cursor_element C2MV5_DEV.PKG_WFSEC.WFSEC_Send_Item_T;
BEGIN
  P_USERID := 11;
  
  PKG_WFSEC.FETCHSENDITEMS(
    P_USERID =&amp;gt; P_USERID,
    P_CURSOR =&amp;gt; MY_P_CURSOR
  );

 WHILE TRUE LOOP
    FETCH MY_P_CURSOR INTO cursor_element;
    EXIT WHEN MY_P_CURSOR%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE(cursor_element.executingdoctorname);
  END LOOP;

END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merk op dat hier bijvoorbeeld &lt;code&gt;cursor_element&lt;/code&gt; van een bepaald type is dat in een package gedefinieerd is, dat de cursor ook retourneert (&lt;code&gt;TYPE Validation_Send_Item_Cursor IS REF CURSOR RETURN WFSEC_Send_Item_T;&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&#34;in-c&#34;&gt;In C#&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        public object QueryProcedure(string procedure, IDictionary&amp;lt;string, object&amp;gt; parameters, string outputParameter)
        {
            var command = new OleDbCommand(procedure);
            foreach (var item in parameters)
            {
                   command.Parameters.AddWithValue(item.Key, item.Value);
            }
            var output = command.Parameters.AddWithValue(outputParameter, 0);
            output.Direction = ParameterDirection.Output;

            QueryProcedure(command);
            return output.Value;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unit-testen&#34;&gt;Unit testen&lt;/h3&gt;

&lt;h4 id=&#34;met-sql-developer&#34;&gt;Met SQL Developer&lt;/h4&gt;

&lt;p&gt;zie &lt;a href=&#34;http://docs.oracle.com/cd/E15846_01/doc.21/e15222/unit_testing.htm&#34;&gt;Oracle docs: Unit Testing in SQL Developer 3+&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;❗ Read this first: &lt;a href=&#34;http://www.fuzzy.cz/en/articles/unit-testing-plsql-code-in-sql-developer-problems/&#34;&gt;Unit Testing PL/SQL In SQL Developer problems&lt;/a&gt; - toch niet zo geweldig? &lt;br/&gt;&lt;br/&gt;
Kan blijkbaar al niet apart gerund worden (mee in de build? een of nadere bat file van SQLDev zelf?)&lt;/p&gt;

&lt;p&gt;&lt;img style=&#39;float: left;&#39; src=&#39;http://www.brainbaking.com/img//code/db/unittest_sqldev.png |&#39;&gt;&lt;/p&gt;

&lt;p&gt;Als uw stored procedure data wijzigt kan je in de startup en teardown process stappen toevoegen: &amp;ldquo;table or row copy&amp;rdquo;, om die daarna terug te zetten.&lt;/p&gt;

&lt;h5 id=&#34;test-gerelateerde-tabellen-opkuisen&#34;&gt;Test gerelateerde tabellen opkuisen&lt;/h5&gt;

&lt;p&gt;Als je database-onafhankelijk testen wil draaien, kan je deze ook exporteren en importeren, en daarna runnen. Een import verwijdert echter niet oude niet-relevante unit tests, dus opkuisen van de UT repository is wel vereist. Hier is een &lt;code&gt;SQL&lt;/code&gt; stored proc. om de boel te automatiseren:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET serveroutput ON;
DECLARE
    queryStr VARCHAR2(100);
    tableName VARCHAR2(900);
    cursor tableCursor is SELECT table_name FROM dba_tables where owner =&#39;user&#39; and table_name like &#39;UT_TEST_%&#39; or table_name like &#39;UT_SUITE_%&#39;;
BEGIN

dbms_output.enable(10000);
DBMS_OUTPUT.PUT_LINE(&#39;Cleaning unit test tables&#39;);

open tableCursor;
fetch tableCursor into tableName;

WHILE (tableCursor%FOUND) LOOP
  queryStr := &#39;delete from &#39; ||tableName;
  execute immediate queryStr;
  --DBMS_OUTPUT.PUT_LINE(queryStr);
  fetch tableCursor into tableName;
END LOOP;
close tableCursor;

commit;
DBMS_OUTPUT.PUT_LINE(&#39;SUCCESS - all cleaned!&#39;);

END;
/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dit kan je runnen met &lt;code&gt;sqlplus&lt;/code&gt; op de volgende manier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlplus user/pass@db @&amp;quot;fullpath_to_filename.sql&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;❗ Let op met spaties in filename, gebruik daarom dubbele quotes hierboven.&lt;/p&gt;

&lt;h5 id=&#34;command-line-testen-runnen&#34;&gt;Command-line testen runnen&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;ututil -run -suite -name [name] -repo [repo] -db [db] -log 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uw repository naam is dezelfde als de DB naam als je Tools &amp;gt; Unit Test &amp;gt; Create/Update Repository&amp;hellip; gekozen hebt via SQL Developer.&lt;/p&gt;

&lt;p&gt;❗ &lt;code&gt;ututil&lt;/code&gt; kan de db connectie namen &lt;strong&gt;niet resolven bij TNS&lt;/strong&gt; - Gebruik &lt;strong&gt;Connection Identifier&lt;/strong&gt; (copypaste desnoods van &lt;code&gt;tnsnames.ora&lt;/code&gt;)&lt;br/&gt;&lt;br/&gt;
Fout die je anders krijgt:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:&amp;lt;br/&amp;gt;oracle&amp;lt;br/&amp;gt;sqldeveloper&amp;lt;br/&amp;gt;sqldeveloper&amp;lt;br/&amp;gt;bin&amp;gt;ututil -run -test -name GETPERMISSIONALL -repo CHCDEV -db CHCTEST -log 3
SEVERE oracle.jdeveloper.db.ConnectionException: Could not connect to database CHCTEST. The error encountered was: Ongeldige verbindingsgegevens opgeg
even.
Controleer de notatie van de URL voor de opgegeven driver.
        oracle.jdeveloper.db.DatabaseConnections.getUniqueConnection(DatabaseConnections.java:514)
SEVERE null - oracle.dbtools.unit_test.utils.UtUtils.getRunnerConnection(UtUtils.java:141)
Unable to run test
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;integratie-met-de-build-c&#34;&gt;Integratie met de build: C#&lt;/h5&gt;

&lt;p&gt;Een &lt;code&gt;SqlDeveloperTest&lt;/code&gt; klasse die het volgende doet:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;voer &lt;code&gt;sqlplus&lt;/code&gt; uit met bovenstaande cleanup script dat alle repository tabellen cleart&lt;/li&gt;
&lt;li&gt;voer &lt;code&gt;ututil&lt;/code&gt; uit met &lt;code&gt;-imp -repo [repo] -file [xmlfile]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;voer &lt;code&gt;ututil&lt;/code&gt; uit met &lt;code&gt;-run&lt;/code&gt; zoals boven aangegeven.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;De eigenlijke unit testen leven dan in uw source control omgeving zoals &lt;code&gt;TFS&lt;/code&gt;, in die ene xml file. Op die manier kan je branchen en zo zonder dat die testen vasthangen aan je DB schema. Joepie!&lt;/p&gt;

&lt;h2 id=&#34;problemen&#34;&gt;Problemen&lt;/h2&gt;

&lt;h4 id=&#34;not-in-retourneert-geen-enkele-resultaten&#34;&gt;NOT IN retourneert geen enkele resultaten ??&lt;/h4&gt;

&lt;p&gt;voorbeeld:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from sch_vac.VAC_TAKEN 
where  ikl_id is not null
and ikl_id not in (select iklnummer from VAC_WERFRES_KANDIDATEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;There are serious problems with subqueries that may return NULL values. It is a good idea to discourage the use of the NOT IN clause (which invokes a subquery) and to prefer &lt;strong&gt;NOT EXISTS&lt;/strong&gt; (which invokes a correlated subquery), since the query returns no rows if any rows returned by the subquery contain null values.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oplossing is dus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from vac_taken taak where ikl_id is not null
and not exists (select 1 from vac_werfres_kandidaten where iklnummer = taak.ikl_id)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>