<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Classes on Brain Baking</title>
    <link>http://www.brainbaking.com/tags/classes/index.xml</link>
    <description>Recent content in Classes on Brain Baking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wouter.groeneveld@gmail.com (Wouter Groeneveld)</managingEditor>
    <webMaster>wouter.groeneveld@gmail.com (Wouter Groeneveld)</webMaster>
    <atom:link href="http://www.brainbaking.com/tags/classes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>classes</title>
      <link>http://www.brainbaking.com/wiki/code/python/classes/</link>
      <pubDate>Wed, 12 Mar 2014 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/python/classes/</guid>
      <description>

&lt;h1 id=&#34;classes&#34;&gt;Classes&lt;/h1&gt;

&lt;p&gt;Handige links:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.diveintopython.net/object_oriented_framework/special_class_methods2.html&#34;&gt;special class methods like _ &lt;em&gt;getattr&lt;/em&gt; _ and _ &lt;em&gt;new&lt;/em&gt; _&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.diveintopython3.net/native-datatypes.html#tuples&#34;&gt;dive into python - native datatypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://python-history.blogspot.be/2010/06/inside-story-on-new-style-classes.html&#34;&gt;Inside story on new style classes&lt;/a&gt; - ter info: Python3 heeft &lt;strong&gt;enkel&lt;/strong&gt; &amp;ldquo;newstyle&amp;rdquo; classes!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;method-overriding&#34;&gt;Method overriding&lt;/h3&gt;

&lt;p&gt;Is &lt;strong&gt;niet mogelijk&lt;/strong&gt;. Gebruik default values!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def func(i, j ###### 2, k  3):
    return i + j + k

func(1) # 6
func(1, 1) # 5
func(1, 1, 1) # 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wat wel gaat, evt met decorators, zie &lt;a href=&#34;http://www.artima.com/weblogs/viewpost.jsp?thread=101605&#34;&gt;Five-minute multimethods in Python&lt;/a&gt; - is &lt;code&gt;_ _call_ _&lt;/code&gt; implementeren en dan met metaprogrammeren te loopen over alle methods en te kijken of de argumenten overeen komen met het type dat required is. Fancypancy!&lt;/p&gt;

&lt;h5 id=&#34;opgelet-met-pitfalls&#34;&gt;Opgelet met pitfalls&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Nummer 1&lt;/strong&gt;: default variables worden herbruikt:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When Python executes a “def” statement, it takes some ready-made pieces (including the compiled code for the function body and the current namespace), and creates a new function object. When it does this, it also evaluates the default values. [&amp;hellip;] Another way to reset the defaults is to simply re-execute the same “def” statement. Python will then create a new binding to the code object, evaluate the defaults, and assign the function object to the same variable as before. But again, only do that if you know exactly what you’re doing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Default als &lt;code&gt;arr ###### []&lt;/code&gt; Gaat de array muteren. Heel handig voor memoization, heel verwarrend anders. Oplossing? &lt;code&gt;arr  None&lt;/code&gt; en dan &lt;code&gt;arr ###### [] if arr  None&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Zie ook &lt;a href=&#34;http://effbot.org/zone/default-values.htm&#34;&gt;Default parameter values in Python&lt;/a&gt; voor in-depth uitleg.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nummer 2&lt;/strong&gt;: &lt;em&gt;Python’s nested scopes bind to variables, not object values&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(10):
    def callback():
        print &amp;quot;clicked button&amp;quot;, i
    UI.Button(&amp;quot;button %s&amp;quot; % i, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;variabele &lt;code&gt;i&lt;/code&gt; gaat altijd 9 zijn - wordt niet op value gebind. Oplossing is explicit binding door de functie definitie van &lt;code&gt;callback():&lt;/code&gt; te veranderen naar &lt;code&gt;callback(i=i):&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;fields-dynamisch-definiëren&#34;&gt;Fields dynamisch definiëren&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Thing(a######1, b2)&lt;/code&gt; kan op een paar manieren gedefiniëerd worden.&lt;/p&gt;

&lt;h5 id=&#34;fields-expliciet-declareren&#34;&gt;fields expliciet declareren&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Thing:
   def __init__(self, a, b):
       self.a, self.b = a, b
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;dynamisch-uw-eigen-dictionary-updaten&#34;&gt;dynamisch uw eigen dictionary updaten&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Thing:
   def __init__(self, **kwargs):
       self.__dict__.update(kwargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;❗ Dit is uiteraard heel gevaarlijk aangezien het al uw method bodies kan vervangen door een param value. BOEM.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;* *name&lt;/code&gt;(zonder spatie, wiki markup, nvdr) geeft alle argumenten in een &lt;a href=&#34;http://docs.python.org/2/library/stdtypes.html#typesmapping&#34;&gt;dict&lt;/a&gt; terug. &lt;code&gt;*name&lt;/code&gt; gaat ook, geeft u een lijst van argumenten terug. Combinatie gaat ook, één ster moet voor de tweede komen. Zoiets is dus mogelijk: &lt;code&gt;def _ _init_ _(self, arg1, arg2, *allargs, * *allargsasdict)&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;alles-als-een-message-passing-systeem-zien&#34;&gt;Alles als een message passing systeem zien&lt;/h5&gt;

&lt;p&gt;In Ruby is er een andere manier om &lt;code&gt;def name block end&lt;/code&gt; te schrijven, hoe het geïnterpreteerd wordt: &lt;code&gt;self.class.send(:name, args) { block }&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def opt_to_s opt={}
  opt.empty? ? &#39;&#39; : &#39; &#39; + opt.map {|e,v| &amp;quot;#{e}=&amp;lt;br/&amp;gt;&amp;quot;#{v}&amp;lt;br/&amp;gt;&amp;quot;&amp;quot;}.join(&#39;, &#39;)
end

[:html, :body, :h1].each do |el|
  start=&amp;quot;&amp;lt;#{el}&amp;quot;
  fin=&amp;quot;&amp;lt;/#{el}&amp;gt;&amp;quot;
  self.class.send(:define_method, el) {|options={}, &amp;amp;blk| start + opt_to_s(options) + &#39;&amp;gt;&#39; + blk.call + fin}
end

# Now, we can neatly nest tags and content
html do
  body do
    h1 :class######&amp;gt;&amp;quot;bold-h1&amp;quot;, :id&amp;gt;&amp;quot;h1_99&amp;quot; do
      &amp;quot;header&amp;quot;
    end
  end
end
 ######&amp;gt; &amp;quot;&amp;lt;body&amp;gt;&amp;lt;h1 class&amp;lt;br/&amp;gt;&amp;quot;bold-h1&amp;lt;br/&amp;gt;&amp;quot;, id=&amp;lt;br/&amp;gt;&amp;quot;h1_99&amp;lt;br/&amp;gt;&amp;quot;&amp;gt;header&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voilà, een DSL in no-time. Holy crap. &lt;a href=&#34;http://rubylearning.com/blog/2010/11/03/do-you-understand-rubys-objects-messages-and-blocks/&#34;&gt;Bron: do you understand ruby&amp;rsquo;s objects messages and blocks?&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;superclassing&#34;&gt;Superclassing&lt;/h3&gt;

&lt;p&gt;Klassen aanmaken is niet al te moeilijk, maar een call uitvoeren naar de overridden method is iets minder evident: zie &lt;a href=&#34;http://docs.python.org/2/library/functions.html#super&#34;&gt;super() in python docs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Een voorbeeld van een custom http handler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class HttpHandler(SimpleHTTPRequestHandler):
	def readStatus(self):
		return {
			&amp;quot;Status&amp;quot;: &amp;quot;blabla&amp;quot;,
			&amp;quot;StartTime&amp;quot;: &amp;quot;&amp;quot;
		}

	def do_GET(self):
		try:
			print(&#39;serving %s now&#39; % self.path)
			if &amp;quot;status.json&amp;quot; in self.path:
				self.send_response(200)
				self.send_header(&#39;Content-type&#39;, &#39;text/json&#39;)
				self.end_headers()
				self.wfile.write(json.dumps(self.readStatus()).encode())
			else:
				SimpleHTTPRequestHandler.do_GET(self)

		except IOError:
			self.send_error(500, &#39;internal server error in server python source: %s&#39; % self.path)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wat is hier speciaal aan:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;super.do_GET(self)&lt;/code&gt; =&amp;gt; &lt;code&gt;SimpleHTTPRequestHandler.do_GET(self)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eigen method aanroepen: &lt;code&gt;self.readStatus()&lt;/code&gt; met de &lt;code&gt;self&lt;/code&gt; prefix&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;diamond-inheritance&#34;&gt;Diamond inheritance&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;BaseClass.method()&lt;/code&gt; is impliciet hetzelfde als &lt;code&gt;super().method()&lt;/code&gt;, behalve dat je met &lt;code&gt;super&lt;/code&gt; een argument kan meegeven, over welke superklasse het gaat.&lt;/p&gt;

&lt;p&gt;Zie ook &lt;a href=&#34;http://www.artima.com/weblogs/viewpost.jsp?thread=236275&#34;&gt;Things to know about Python&amp;rsquo;s super()&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;closures-en-lambda-s&#34;&gt;Closures en lambda&amp;rsquo;s&lt;/h3&gt;

&lt;p&gt;functies in functies aanmaken werkt perfect, &amp;ldquo;closed over&amp;rdquo; die lexicale scope, net zoals je zou verwachten zoals bijvoorbeeld in javascript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;	def readBuildStatus(self):
		html = urllib.request.urlopen(&amp;quot;http://bla/lastbuildstatus.htm&amp;quot;).read().decode()
		def extractVersion():
			versionString = &amp;quot;Version: &amp;quot;
			versionIndex = html.find(&amp;quot;Version: &amp;quot;)
			return html[versionIndex + len(versionString) : versionIndex + len(versionString) + len(&amp;quot;YYYY.MM&amp;quot;)]
		def extractStatus():
			return &amp;quot;Succeeded&amp;quot; if html.find(&amp;quot;SUCCESS&amp;quot;) != -1 else &amp;quot;Failed&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;de twee andere methods lezen de &lt;code&gt;html&lt;/code&gt; variabele uit. Hier hoef je geen &lt;code&gt;self.&lt;/code&gt; prefix te gebruiken, binnen de &lt;code&gt;readBuildStatus()&lt;/code&gt; functie zelf - hierbuiten zijn de closures verdwenen natuurlijk (out of scope).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>classes</title>
      <link>http://www.brainbaking.com/wiki/code/ruby/classes/</link>
      <pubDate>Tue, 11 Mar 2014 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/ruby/classes/</guid>
      <description>

&lt;h1 id=&#34;ruby-classes&#34;&gt;Ruby Classes&lt;/h1&gt;

&lt;h3 id=&#34;closures-and-lambda-s&#34;&gt;Closures and lambda&amp;rsquo;s&lt;/h3&gt;

&lt;p&gt;Weer 4 verschillende mogelijkheden in Ruby, zie &lt;a href=&#34;http://techspry.com/ruby_and_rails/proc-and-lambda-in-ruby/&#34;&gt;Proc and Lambda in Ruby&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;native-blocks-aanmaken&#34;&gt;Native &amp;ldquo;blocks&amp;rdquo; aanmaken&lt;/h5&gt;

&lt;p&gt;Is niet mogelijk. &lt;code&gt;a = { puts &amp;quot;hello&amp;quot; }&lt;/code&gt; geeft een Syntax error; dit moet effectief met &lt;code&gt;Proc.new&lt;/code&gt; gebeuren.&lt;/p&gt;

&lt;h5 id=&#34;lambdas-aanmaken&#34;&gt;Lambdas aanmaken&lt;/h5&gt;

&lt;p&gt;Kan ook weer op twee manieren:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a = lambda { puts &amp;quot;hello&amp;quot; }
b = -&amp;gt; { puts &amp;quot;hello&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;blocks-als-argumenten-doorgeven&#34;&gt;Blocks als argumenten doorgeven&lt;/h5&gt;

&lt;p&gt;Wordt slechts één aanvaard, &lt;code&gt;Proc&lt;/code&gt;s zijn objecten en kan dus op eender welke manier. Een block is eerder deel van de taal als syntax. (zoals bij &lt;code&gt;do&lt;/code&gt;)&lt;/p&gt;

&lt;h5 id=&#34;een-lambda-is-een-proc&#34;&gt;Een lambda is een Proc&lt;/h5&gt;

&lt;p&gt;Met twee grote verschillen (zie &lt;a href=&#34;http://awaxman11.github.io/blog/2013/08/05/what-is-the-difference-between-a-block/&#34;&gt;What is the difference between a block, a proc and a lambda in ruby?&lt;/a&gt;):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;een &lt;code&gt;lambda&lt;/code&gt; controleert argumenten, een &lt;code&gt;Proc&lt;/code&gt; kan het niet schelen.&lt;/li&gt;
&lt;li&gt;een &lt;code&gt;return&lt;/code&gt; statement in een &lt;code&gt;lambda&lt;/code&gt; stopt slechts de closure. In een &lt;code&gt;Proc&lt;/code&gt; stopt het de hele enclosing method ❗&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def proc_test
  proc = Proc.new { return }
  proc.call
  puts &amp;quot;Hello world&amp;quot;
end

proc_test                 # calling proc_test prints nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;class-methods&#34;&gt;Class methods&lt;/h3&gt;

&lt;p&gt;Zie &lt;a href=&#34;http://www.railstips.org/blog/archives/2009/05/11/class-and-instance-methods-in-ruby/&#34;&gt;Class and instance methods in Ruby&lt;/a&gt;. Er zijn verschillende manieren om een class method te maken in ruby:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Way 1
class Foo
  def self.bar
    puts &#39;class method&#39;
  end
end

Foo.bar # &amp;quot;class method&amp;quot;

# Way 2
class Foo
  class &amp;lt;&amp;lt; self
    def bar
      puts &#39;class method&#39;
    end
  end
end

Foo.bar # &amp;quot;class method&amp;quot;

# Way 3
class Foo; end
def Foo.bar
  puts &#39;class method&#39;
end

Foo.bar # &amp;quot;class method&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instance methods worden met &lt;code&gt;def name&lt;/code&gt; gedefiniëerd, zoals men intuïtief zou aannemen (wow).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>classes</title>
      <link>http://www.brainbaking.com/wiki/code/csharp/classes/</link>
      <pubDate>Wed, 29 Jan 2014 00:00:00 +0000</pubDate>
      <author>wouter.groeneveld@gmail.com (Wouter Groeneveld)</author>
      <guid>http://www.brainbaking.com/wiki/code/csharp/classes/</guid>
      <description>

&lt;h1 id=&#34;classes&#34;&gt;Classes&lt;/h1&gt;

&lt;h2 id=&#34;dynamically-creating-instances&#34;&gt;Dynamically creating instances&lt;/h2&gt;

&lt;p&gt;Gebruik &lt;code&gt;Activator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Activator.CreateInstance(type) as MyType
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;overrides-en-shadowing-new-en-virtual&#34;&gt;Overrides en shadowing: &amp;lsquo;new&amp;rsquo; en &amp;lsquo;virtual&amp;rsquo;&lt;/h2&gt;

&lt;p&gt;Zie onder andere:
  1. &lt;a href=&#34;http://stackoverflow.com/questions/1014295/new-keyword-in-method-signature&#34;&gt;http://stackoverflow.com/questions/1014295/new-keyword-in-method-signature&lt;/a&gt;
  2. &lt;a href=&#34;http://stackoverflow.com/questions/9892468/java-is-there-java-equivalent-for-c-sharp-new-keyword-in-method-signature-how&#34;&gt;http://stackoverflow.com/questions/9892468/java-is-there-java-equivalent-for-c-sharp-new-keyword-in-method-signature-how&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In java zijn alle methods &lt;code&gt;virtual&lt;/code&gt;, dat wil zeggen dat ze overschrijfbaar zijn (&lt;code&gt;@Override&lt;/code&gt;) zodat de method in de diepst geneste polymorfe structuur gebruikt wordt. In C# is daarvoor het keyword &lt;code&gt;virtual&lt;/code&gt; nodig:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class A
{
   public virtual void One();
   public void Two();
}

public class B : A
{
   public override void One();
   public new void Two();
}

B b = new B();
A a = b as A;

a.One(); // Calls implementation in B
a.Two(); // Calls implementation in A
b.One(); // Calls implementation in B
b.Two(); // Calls implementation in B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De concretere klasse moet dan overriden met &lt;code&gt;override&lt;/code&gt; dat niet gaat als het niet &lt;code&gt;virtual&lt;/code&gt; is (je kan ook niet overerven waarbij een klasse &lt;code&gt;sealed&lt;/code&gt; is, zoals &lt;code&gt;final&lt;/code&gt; in java). Wat hier wel opmerkelijk is, is het gebruik van het keyword &lt;code&gt;new&lt;/code&gt; in de tweede method &amp;ldquo;Two&amp;rdquo;. Hierbij kan je de eerste implementatie toch nog hiden, maar je moet wel upcasten! Misschien is dit nog handig bij het schrijven van legacy testen?&lt;/p&gt;

&lt;p&gt;Het is in java niet mogelijk om een &lt;code&gt;final&lt;/code&gt; method te overriden. (Private telt natuurlijk niet mee&amp;hellip;) In C# is het &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa645769(v=vs.71).aspx&#34;&gt;wel mogelijk om halverwege de chain te sealen&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&#34;closures-en-lambda-s&#34;&gt;Closures en Lambda&amp;rsquo;s&lt;/h2&gt;

&lt;p&gt;Interessante links:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb397687.aspx&#34;&gt;Lambda expressions MSDN C# programming guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb397951.aspx&#34;&gt;Expression Trees MSDN&lt;/a&gt; hier worden lambda&amp;rsquo;s gebruikt voor LINQ&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;passing-on-work-to-a-method-to-execute-the-lambda&#34;&gt;Passing on &amp;lsquo;work&amp;rsquo; to a method, to execute the lambda&lt;/h3&gt;

&lt;p&gt;In Java:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Workable&amp;lt;T&amp;gt; {
  public T work();
}

public class MyWork extends Workable&amp;lt;MyObj&amp;gt; {
  public MyObj work() {
    // do stuff here 
  } 
}

public class Executer {
  public &amp;lt;T&amp;gt; T doStuff(Workable&amp;lt;T&amp;gt; w) {
     prepare();
     T result = w.work();
     cleanup();
  }

  public MyObj createMyObj() {
    return doStuff(new MyWork());
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, gebruik interfaces. Pijnlijk en verbose. In C# kan je &lt;code&gt;() =&amp;gt;&lt;/code&gt; gebruiken om een anonieme method aan te maken, en &lt;code&gt;Func&amp;lt;&amp;gt;&lt;/code&gt; als type gebruiken. &lt;br/&gt;&lt;br/&gt;
Concreet voorbeeld:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        internal virtual T Execute&amp;lt;T&amp;gt;(Func&amp;lt;T&amp;gt; work)
        {
            Connection.Open();
            var transaction = Connection.BeginTransaction();
            try
            {
                var retVal = work.Invoke();
                transaction.Commit();
                return retVal;
            }
            catch (Exception)
            {
                transaction.Rollback();
                throw;
            }
            finally
            {
                Connection.Close();
            }
        }
        
        public bool BlaBla()
        {
          return Execute(() =&amp;gt;
          {
              // do query stuff in here.
              return true;
          });
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;q-wat-is-het-verschil-tussen-een-lambda-en-een-delegate&#34;&gt;Q: Wat is het verschil tussen een Lambda (&amp;gt;()) en een delegate?&lt;/h5&gt;

&lt;p&gt;A: niets; zie voorbeeld:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Func&amp;lt;string, int&amp;gt; giveLength = delegate(string text) { return text.Length; };
Func&amp;lt;string, int&amp;gt; giveLength ###### (text &amp;gt; text.length);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;de &lt;code&gt;=&amp;gt;&lt;/code&gt; notatie is nieuwer.&lt;/p&gt;

&lt;h6 id=&#34;q-wat-is-het-verschil-tussen-een-expression-type-en-een-anonymous-type&#34;&gt;Q: Wat is het verschil tussen een expression type en een anonymous type?&lt;/h6&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/299703/delegate-keyword-vs-lambda-notation&#34;&gt;http://stackoverflow.com/questions/299703/delegate-keyword-vs-lambda-notation&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you assign the lambda to a delegate type (such as Func or Action) you&amp;rsquo;ll get an anonymous delegate.
If you assign the lambda to an Expression type, you&amp;rsquo;ll get an expression tree instead of a anonymous delegate. The expression tree can then be compiled to an anonymous delegate.
Edit: Here&amp;rsquo;s some links for Expressions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zeer interessant artikel: &lt;a href=&#34;http://weblogs.asp.net/scottgu/archive/2007/04/08/new-orcas-language-feature-lambda-expressions.aspx&#34;&gt;http://weblogs.asp.net/scottgu/archive/2007/04/08/new-orcas-language-feature-lambda-expressions.aspx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;############ Nested (inner) classes in C# ############&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blogs.msdn.com/b/oldnewthing/archive/2006/08/01/685248.aspx&#34;&gt;http://blogs.msdn.com/b/oldnewthing/archive/2006/08/01/685248.aspx&lt;/a&gt; - C# heeft geen referentie naar de outer class (&lt;code&gt;$0&lt;/code&gt; die in Java er impliciet is), bijgevolg moet je dit zelf bijhouden.&lt;/p&gt;

&lt;p&gt;Zie ook &lt;a href=&#34;http://stackoverflow.com/questions/4770180/anonymous-inner-classes-in-c-sharp&#34;&gt;http://stackoverflow.com/questions/4770180/anonymous-inner-classes-in-c-sharp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;############ Modules as anonymous inner classes, JavaScript pattern ############&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Mod = (function(consoleDep) {
	
	function yo() {
		consoleDep.log(&amp;quot;yo&amp;quot;);
	}

	return {
		hi: yo
	};

})(console);

Mod.hi();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;equals&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        private interface ILoggable
        {
            void Log(string msg);
        }

        private class Console : ILoggable
        {
            public void Log(string msg)
            {
                Debug.WriteLine(msg);
            }
        }

        [TestMethod]
        public void TestMe()
        {
            var Mod ###### new Func&amp;lt;ILoggable, Dictionary&amp;lt;string, Action&amp;gt;&amp;gt;((consoleDep) &amp;gt;
                {
                    Action yo ###### () &amp;gt; consoleDep.Log(&amp;quot;yo&amp;quot;);

                    return new Dictionary&amp;lt;string, Action&amp;gt;
                        {
                            { &amp;quot;hi&amp;quot;, yo }
                        };
                })(new Console());
            Mod[&amp;quot;hi&amp;quot;]();
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Problemen&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cannot assign lambda expression to an implicitly-typed local variable (&lt;code&gt;var&lt;/code&gt; bij de yo ipv &lt;code&gt;Action&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;duck typing for module dependencies??&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;############= Enums in C# ############=&lt;/p&gt;

&lt;p&gt;Zie ook &lt;a href=&#34;http://stackoverflow.com/questions/469287/c-sharp-vs-java-enum-for-those-new-to-c&#34;&gt;http://stackoverflow.com/questions/469287/c-sharp-vs-java-enum-for-those-new-to-c&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Enumerations in the CLR are simply named constants. The underlying type must be integral. In Java an enumeration is more like a named instance of a type. That type can be quite complex and - as your example shows - contain multiple fields of various types.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Optie 1: gebruik &lt;strong&gt;extensions&lt;/strong&gt; (nog altijd een switch nodig omdat het type in algemene vorm binnen komt)&lt;/p&gt;

&lt;p&gt;Optie 2: maak uw eigen enum klasse door immutable readonly classes te maken:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;class Planet
{
  public static readonly Planet EARTH = new Planet(&amp;quot;earth&amp;quot;);

  private string name;
  private Planet(string name)
  {
    this.name = name;
  }
  
  public static IEnumerable&amp;lt;Planet&amp;gt; Values
  {
    // return set of planets
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>