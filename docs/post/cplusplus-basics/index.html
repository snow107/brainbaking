<!DOCTYPE html>
<html lang="en-us">
    <head>
        <link rel="stylesheet" href="https://brainbaking.com/css/brainbaking.css">



	<meta name="description" content="C&#43;&#43; Basics - C&#43;&#43; basics for a Java developer">
	<meta content="C&#43;&#43; Basics" property="og:title">
	<meta content="C&#43;&#43; basics for a Java developer" property="og:description">



  <meta content="c&#43;&#43;" name="keywords">


<meta property="og:url" content="https://brainbaking.com/post/cplusplus-basics/" />
<meta property="og:type" content="website" />





<meta property="article:published_time" content="2013-10-01 00:00:00 &#43;0000 UTC" />
<meta property="article:modified_time" content="2013-10-01 00:00:00 &#43;0000 UTC" />
<meta property="article:section" content="post" />

  <meta property="article:tag" content="c&#43;&#43;" />




<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://brainbaking.com/"
    },
    "articleSection" : "post",
    "name" : "C&#43;&#43; Basics",
    
      "headline" : "C&#43;&#43; basics for a Java developer",
    
    "description" : "Scope C++ heeft block level scope, net als Java, alleen is het mogelijk om een variabele binnen een for loop dezelfde naam te geven als een die buiten die block gedefiniëerd is, terwijl dat in Java niet gaat:
int j; for(int i = 0; i &lt; 10; i++) { int j = i + 1; // compile fout in java }  Pointer scope auto_ptr kan gebruikt worden om een pointer automatisch te verwijderen met delete wanneer deze scope verliest - alle andere zaken moet je zelf opkuisen.",
    
      "inLanguage" : "en-US",
    
    
      "image": "https://brainbaking.com/img/avatar-icon.png",
    
    "author" : {
    	"@type": "Person",
    	"name": "Wouter Groeneveld"
	  },
    "publisher": {
    	"@type": "Organization",
    	"name": "Brain Baking",
    	"logo": {
    		"@type": "ImageObject",
    		"url": "https://brainbaking.com/img/avatar-icon.png"
    	}
	  },
    "accountablePerson" : "Wouter Groeneveld",
    "copyrightHolder" : "Wouter Groeneveld",
    "copyrightYear" : "2013",
    "datePublished": "2013-10-01 00:00:00 &#43;0000 UTC",
    "dateModified" : "2018-05-03 16:09:41 &#43;0200 CEST",
    "url" : "https://brainbaking.com/post/cplusplus-basics/",
    "wordCount" : "2238",
    "keywords" : [ "c&#43;&#43;","C&#43;&#43; Basics", "post" ]
}
</script>



<script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-45748221-1', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>C&#43;&#43; Basics</title>
        
        <style>

    html body {
        font-family: 'Source Serif Pro', sans-serif;
        background-color: white;
    }

    :root {
    	--accent: purple;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://brainbaking.com/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source%20Serif%20Pro">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/paraiso-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/cs.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/cpp.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scheme.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/llvm.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.53" />
        
    </head>

    
    
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    

    <body>
         
        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">C&#43;&#43; Basics</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/post"><i class='fa fa-file-code-o'></i>&nbsp;Tech Blog</a></li>
                            
                                <li><a href="/essays"><i class='fa fa-book'></i>&nbsp;Essays</a></li>
                            
                                <li><a href="/tags"><i class='fa fa-tags'></i>&nbsp;Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li><a href="/about"><i class='fa fa-user'></i>&nbsp;About Me</a></li>
                            
                                <li><a href="/teaching"><i class='fa fa-graduation-cap'></i>&nbsp;Teaching</a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>




<main>

    <a name="top"></a>
    <div class="item">

    
    <h3>
        
        <a href="/post/cplusplus-basics/">C&#43;&#43; Basics</a>
    </h3>
    

    
    
    
        <h4>C&#43;&#43; basics for a Java developer</h4>
        <h5>
        	<span style="color: grey;">
        		<span title="Created Date">
                    <i class='fa fa-calendar'></i>&nbsp;1 October 2013
                </span>&nbsp;|&nbsp;
                <span title="Last Modified Date">
                    <i class='fa fa-calendar-check-o'></i>&nbsp;3 May 2018
                </span>
    		</span>
    	</h5>
    


    
	   <i class='fa fa-tags' style='color: grey;'></i>&nbsp;
    
    
        <a href="https://brainbaking.com/tags/c&#43;&#43;"><kbd class="item-tag">c&#43;&#43;</kbd></a>
    

</div>


    <br> <div class="text-justify">

<h2 id="scope">Scope</h2>

<p>C++ heeft block level scope, net als Java, alleen is het mogelijk om een variabele binnen een for loop dezelfde naam te geven als een die buiten die block gedefiniëerd is, terwijl dat in Java niet gaat:</p>

<pre><code class="language-c">int j;
for(int i = 0; i &lt; 10; i++) {
  int j = i + 1; // compile fout in java
}
</code></pre>

<h3 id="pointer-scope">Pointer scope</h3>

<p><a href="https://en.wikipedia.org/wiki/Auto_ptr">auto_ptr</a> kan gebruikt worden om een pointer automatisch te verwijderen met <code>delete</code> wanneer deze scope verliest - alle andere zaken moet je zelf opkuisen.
❗️ Dit is deprecated in C++ 11, gebruik <a href="https://en.wikipedia.org/wiki/Smart_pointer#unique_ptr">unique_ptr</a></p>

<p>Voorbeeld van wikipedia:</p>

<pre><code class="language-c">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
 
int main(int argc, char **argv)
{
    int *i = new int;
    auto_ptr&lt;int&gt; x(i);
    auto_ptr&lt;int&gt; y;
 
    y = x;
 
    cout &lt;&lt; x.get() &lt;&lt; endl; // Print NULL
    cout &lt;&lt; y.get() &lt;&lt; endl; // Print non-NULL address i
 
    return 0;
}
</code></pre>

<h2 id="overloading-virtual">overloading: &lsquo;virtual&rsquo;</h2>

<p>In java wordt by default het diepste gedefiniëerde element opgeroepen, in C++ ben je verplicht <code>virtual</code> te gebruiken als &ldquo;optimalisatie&rdquo; wordt dit standaard niet gedaan&hellip; Voorbeeld:</p>

<pre><code class="language-c">class Simple
{
public:
	Simple() : someMember(3) {}
	virtual int guessNumber();
	int someMember;
};
</code></pre>

<pre><code class="language-c">#include &quot;simplecpp.h&quot;

int Simple::guessNumber()
{
	return 5;
}
</code></pre>

<p>Als je nu <code>guessNumber()</code> wil overschrijven in een subklasse kan dit:</p>

<pre><code class="language-c">#include &quot;simplecpp.h&quot;

class Complexer : public Simple
{
public:
	Complexer() {}
	int guessNumber();
};
</code></pre>

<p>Merk op, te overschrijven method heropsommen in header file&hellip; (??) - hier hoeft geen <code>virtual</code> meer bij dan.</p>

<pre><code class="language-c">#include &quot;complexer.h&quot;

int Complexer::guessNumber()
{
	return 10;
}
</code></pre>

<p>Wat is hier de uitkomst van:</p>

<pre><code class="language-c">
#include &quot;complexer.h&quot;
#include &lt;iostream&gt;

int main()
{
	Simple* simple = new Complexer();
	std::cout &lt;&lt; simple-&gt;guessNumber();
	delete simple;
}
</code></pre>

<ol>
<li>Haal <code>virtual</code> weg. 5. <br/><br/>
Definiëer <code>Complexer</code> zo:</li>
</ol>

<pre><code class="language-c">Complexer* complexer = new Complexer();
</code></pre>

<p>En het is altijd 10.</p>

<h2 id="initialisatie">Initialisatie</h2>

<p>(Voorbeelden van bovenstaande)</p>

<pre><code class="language-c">#include &quot;complexer.h&quot;
#include &lt;iostream&gt;

int main()
{
	Simple simpleInitialized; // oops, I created something?
	// Simple simpleInitialized = NULL; cannot convert from 'int' to 'Simple' (#define NULL 0)

	Simple* simplePtr;

	std::cout &lt;&lt; &quot;&lt;br/&gt;n initialiezd: &quot; &lt;&lt; simplePtr-&gt;someMember;
	// Run-Time Check Failure #3 - The variable 'simplePtr' is being used without being initialized

	delete simplePtr;
}
</code></pre>

<p>Wat is hier speciaal aan?</p>

<ol>
<li>In C++ wordt altijd een object aangemaakt als je ze declareert. In Java niet!</li>
<li>In C++ is <code>NULL</code> gedefiniëerd als <code>#define NULL 0</code> - je kan dus niet zomaar iets toekennen hieraan. In C++ 11 heb je <code>nullptr</code></li>
<li>Je kan wel een pointer declareren zonder een waarde toe te kennen, en dit geeft dan een run-time fout (zou bvb een <code>NullPointerException</code> gooien in java)</li>
</ol>

<h2 id="typecasting">Typecasting</h2>

<p>Uitgebreide uitleg: zie <a href="http://www.cplusplus.com/doc/tutorial/typecasting/">http://www.cplusplus.com/doc/tutorial/typecasting/</a></p>

<p>In C++ is één impliciete conversie mogelijk door middel van de constructor, bijvoorbeeld:</p>

<pre><code class="language-c">class Something
{
 public:
   Something(int i) : myVar(i) {}
 private:
  int myVar;
}

int getal = 10;
Something something = getal; // use constructor
</code></pre>

<p>Om dit tegen te gaan kan je altijd het <code>explicit</code> keyword gebruiken, zodat je dit moet doen:</p>

<pre><code class="language-c">Something something = Something(getal); // expliciet oproepen constructor
</code></pre>

<p>Je kan <code>staic_cast&lt;Type&gt;(var)</code> gebruiken om explicit constructors aan te roepen, zo kunnen ze dan toch nog gecast worden.</p>

<h2 id="c-11-goodies">C++ 11 goodies</h2>

<p>Algemeen: <a href="http://www.informit.com/articles/article.aspx?p=1910142">How C++ 11 helps boost your productivity</a></p>

<ol>
<li><a href="http://www.codeproject.com/Articles/277612/Using-lambdas-Cplusplus-vs-Csharp-vs-Cplusplus-CX">Lambdas</a> zijn mogelijk</li>
<li><code>nullptr</code></li>
<li><code>auto</code> keyword, zoals <code>var</code> in C# - dit is typesafe en door de compiler zelf bepaald.</li>
<li>100% multithreading support, zie hieronder</li>
</ol>

<h1 id="linking-obj-dlls">Linking obj/dlls</h1>

<p>Probleemstelling: verschillende <strong>solutions</strong>, code over solutions heen willen gebruiken.</p>

<p>Dit compileert by default altijd, maar tijdens het linken van de gecompileerde files loopt het mis. Waarom? Omdat er geen <code>dllexport</code> voorzien is.
<br/><br/> Op te lossen:</p>

<pre><code class="language-c">#ifndef RESOURCE_UTILS_H
#define RESOURCE_UTILS_H

#include &quot;Utility.h&quot;

#ifdef _DLL
  #define DllExImport __declspec(dllexport)
#else
  #define DllExImport __declspec(dllimport)
#endif


class DllExImport ResourceUtils
{
public:
  static RAIIObject&lt;HICON&gt; getIcon(int resourceId);
  static RAIIObject&lt;HICON&gt; getIcon(HINSTANCE resourceHandleInstance, int resourceId);

private:
  ResourceUtils() {}
};

#endif
</code></pre>

<p>in de cpp file hoeft niets speciaal meer te staan.</p>

<h4 id="functies-exposen-voor-native-calls">Functies exposen voor native calls</h4>

<p>Zelfde principe om klassen te exposen met <code>_ _declspec(dllexport)</code>. Gebruik eventueel std calls (C# heeft dit nodig): <code>DllExImport MyStruct* _ _stdcall GetSignals();</code>.</p>

<h4 id="properties-van-solutions">Properties van solutions</h4>

<h5 id="die-de-te-exporteren-code-bevat">Die de te exporteren code bevat</h5>

<ol>
<li>Configuration type: Dynamic Libraray (DLL)</li>
<li>Incremental linking: Yes (/INCREMENTAL)</li>
<li>Link Linkage Deps: Yes</li>
<li>Output file: *.dll</li>
</ol>

<h5 id="die-de-code-bevat-die-gebruik-maakt-van-de-dll">Die de code bevat die gebruik maakt van de dll</h5>

<ol>
<li>Linker; Input: Additional dependencies ../OtherSolution.lib</li>
</ol>

<h3 id="shared-libraries-linken-in-unix">Shared libraries linken in Unix</h3>

<p><code>declspec</code> is Win32 specifiek. Lees alles over GCC Visibility in <a href="http://gcc.gnu.org/wiki/Visibility">GNU GCC Wiki on Visibility</a>. Komt op dit neer:</p>

<pre><code class="language-c">#if defined(_MSC_VER)
    //  Microsoft 
    #define EXPORT __declspec(dllexport)
    #define IMPORT __declspec(dllimport)
#elif defined(_GCC)
    //  GCC
    #define EXPORT __attribute__((visibility(&quot;default&quot;)))
    #define IMPORT
#else
    //  do nothing and hope for the best?
    #define EXPORT
    #define IMPORT
    #pragma warning Unknown dynamic link import/export semantics.
#endif
</code></pre>

<p>Zie ook <a href="http://www.akkadia.org/drepper/dsohowto.pdf">How to write shared Libraries</a> by Ulrich Drepper.</p>

<h1 id="mfc">MFC</h1>

<p>❗️ MFC en AFX <a href="http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library">is hetzelfde</a>:</p>

<blockquote>
<p>One interesting quirk of MFC is the use of &ldquo;Afx&rdquo; as the prefix for many functions, macros and the standard precompiled header name &ldquo;stdafx.h&rdquo;. During early development what became MFC was called &ldquo;Application Framework Extensions&rdquo; and abbreviated &ldquo;Afx&rdquo;. The name Microsoft Foundation Classes (MFC) was adopted too late in the release cycle to change these references</p>
</blockquote>

<h3 id="strings-in-mfc">Strings in MFC</h3>

<p>Gebruik <code>CString</code> - werkt niet op non-win32 omgevingen.</p>

<h5 id="formatting">Formatting</h5>

<p>Formatten kan bijvoorbeeld met <code>string.Format(_T(&quot;%s in %d&quot;), otherString, otherDecimal);</code></p>

<p>❗️ Om een string te intialiseren en toe te kennen moet je wel de <code>_T</code> macro gebruiken</p>

<h5 id="substringen">Substringen</h5>

<p><code>Find</code> is hetzelfde als <code>indexOf</code> in andere talen.</p>

<pre><code class="language-c++">CString HostServiceProxy::GetCouponFromResponseString(CString response)
{
  CString couponKey ###### _T(&quot;Coupon&quot;);
  CString couponPart = response.Mid(response.Find(couponKey) + couponKey.GetLength());

  return couponPart.Left(couponPart.Find(_T(&quot;;&quot;)));
}
</code></pre>

<h3 id="resource-handling">Resource handling</h3>

<p>Icons en images worden opgeslagen in .rc files die als resources in de code gekoppeld kunnen worden aan bijvoorbeeld een <code>CButton</code>. Hoe?</p>

<pre><code class="language-c">  HANDLE hImage = ::LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(resourceId), IMAGE_ICON, 16, 15, LR_DEFAULTCOLOR);
  if(hImage ###### NULL)
    ASSERT(FALSE);  

  HICON image = static_cast&lt;HICON&gt;(hImage);
</code></pre>

<p><code>HICON</code> is van <code>WinDef.h</code> en <code>::LoadImage</code> zit op <code>WinUser.h</code>. Zie <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms648045(v=vs.85).aspx">MSDN doc</a> voor LoadImage.</p>

<h4 id="de-juiste-resource-handle-vastkrijgen">De juiste resource handle vastkrijgen</h4>

<p>Als je een MFC DLL maakt, gaat <code>AfxGetResourceHandle()</code> verwijzen naar de resource handle van uw DLL zelf. Als je dus resources wil vastpakken van een andere DLL heb je pech. Als je geen MFC DLL maakt kan je dit aanpassen met <code>AFX_MANAGE_STATE(AfxGetStaticModuleState( ))</code>. <strong>Dit gooit echter linking errors</strong> ( error LNK2005: _DllMain@12 already defined) indien je dit vanuit een MFC DLL aanroept - dan is dit niet nodig.</p>

<p>Meer uitleg hierover: zie <a href="http://support.microsoft.com/kb/161589">http://support.microsoft.com/kb/161589</a></p>

<p>❗️ de Afx resource handle kan <strong>altijd</strong> gewijzigd worden door leuke dingen te doen als:</p>

<pre><code class="language-c">  HINSTANCE old = AfxGetResourceHandle();
  AfxSetResourceHandle(GetModuleHandle(&quot;andereModule&quot;));
</code></pre>

<p>Gebruik daarom best <code>::GetModuleHandle(char*)</code> bij <code>::LoadImage</code>.</p>

<h4 id="resources-op-het-juiste-moment-terug-vrijgeven">Resources op het juiste moment terug vrijgeven</h4>

<p>Resources worden meestal gewrapped in kleine objectjes die bij de constructor de resource alloceren en bij de destructor deze terug vrijgeven in plaats van in <code>try { ... }</code> zoiets te moeten doen in Java. Dit pattern is <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> of &ldquo;Resource Acquisition Is Initialization&rdquo;. Voorbeeld:</p>

<pre><code class="language-c">template&lt;class TObject&gt;
class RAIIObject
{
public:
  explicit RAIIObject(const TObject&amp; obj) : m_Object(obj) {}
  RAIIObject() {}
  ~RAIIObject() {ReleaseObject();}
  RAIIObject&lt;TObject&gt;&amp; operator######(const TObject&amp; obj) {if(&amp;obj ! &amp;m_Object) {ReleaseObject(); m_Object = obj;} return *this;}
  RAIIObject&lt;TObject&gt;&amp; operator######(const RAIIObject&lt;TObject&gt;&amp; obj) {if(&amp;obj ! this) {ReleaseObject(); m_Object = obj;} return *this;}
  TObject&amp; GetObject() {return m_Object;}
  const TObject&amp; GetObject() const {return m_Object;}
  operator TObject&amp;() {return m_Object;}
  operator const TObject&amp;() const {return m_Object;}
private:
  void ReleaseObject();
  TObject m_Object;
};

template&lt;&gt; inline void RAIIObject&lt;HICON&gt;::ReleaseObject() {::DestroyIcon(m_Object); m_Object = NULL;}
template&lt;&gt; inline void RAIIObject&lt;CBrush&gt;::ReleaseObject() {m_Object.DeleteObject();}
template&lt;&gt; inline void RAIIObject&lt;CBitmap&gt;::ReleaseObject() {m_Object.DeleteObject();}
template&lt;&gt; inline void RAIIObject&lt;CFont&gt;::ReleaseObject() {m_Object.DeleteObject();}
template&lt;&gt; inline void RAIIObject&lt;CMenu&gt;::ReleaseObject() {m_Object.DestroyMenu();}
</code></pre>

<h1 id="preprocessing">Preprocessing</h1>

<h2 id="handige-macro-s">Handige macro&rsquo;s</h2>

<h5 id="exception-debug-informatie-expanden">Exception/Debug informatie expanden</h5>

<pre><code class="language-c++">#define _ERROR_STR2(a) #a
#define _ERROR_STR(a) _ERROR_STR2(a)
#define ERROR_INFO(fn) _T(_ERROR_STR(__FILE__&quot; line: &quot;__LINE__&quot; function: &quot;fn))
</code></pre>

<p>Te gebruiken als <code>someFn(ERROR_INFO(&quot;bla&quot;))</code>. Merk op dat <code>__FUNCTION__</code> of <code>__FUNC__</code> ook gebruikt kan worden, afhankelijk van de C++ compiler, maar dit is geen deel van de standaard (vanaf C++ v11).</p>

<p>De <code>#a</code> notatie wordt gebruikt om iets te <a href="http://gcc.gnu.org/onlinedocs/cpp/Stringification.html">stringifyen</a> in de preprocessor, vandaar de delegate:</p>

<blockquote>
<p>Sometimes you may want to convert a macro argument into a string constant. Parameters are not replaced inside string constants, but you can use the ‘#’ preprocessing operator instead. When a macro parameter is used with a leading ‘#’, the preprocessor replaces it with the literal text of the actual argument, converted to a string constant. Unlike normal parameter replacement, the argument is not macro-expanded first. This is called stringification.</p>
</blockquote>

<h1 id="threading">Threading</h1>

<p>Handige links:</p>

<ol>
<li><a href="http://www.codeproject.com/Articles/7953/Thread-Synchronization-for-Beginners">Thread synchronization for beginners</a></li>
</ol>

<h2 id="thread-safe-singleton-pattern">Thread-safe Singleton pattern</h2>

<p>Bijna onmogelijk in C++ &lt; v11 blijkbaar?</p>

<p>Onderstaand voorbeeld gebruikt Win32 code (<code>WaitForSingleObject</code>) en een mutex om te wachten:</p>

<pre><code class="language-c++">#pragma once
#include &lt;WinBase.h&gt;

class AddinProcessService 
{
    static AddinProcessService *singletonInstance;
  AddinProcessService() : m_coupon(_T(&quot;&quot;)), m_hostServiceAddress(_T(&quot;&quot;)) {}

  public:

  inline const CString&amp; GetHostServiceAddress() const
  {
    return m_hostServiceAddress;
  }
  inline const CString&amp; GetCoupon() const
  {
    return m_coupon;
  }
  inline void SetCoupon(CString coupon)
  {
    m_coupon = coupon;
  }
  inline void SetHostServiceAddress(CString address) 
  {
    m_hostServiceAddress = address;
  }

    static AddinProcessService* getSingletonInstance()
    {
    static volatile int initialized = 0;
    static HANDLE mtx;

    if (!initialized)
    {
        if (!mtx)
        {
          HANDLE mymtx;
          mymtx = CreateMutex(NULL, 0, NULL);
          if (InterlockedCompareExchangePointer(&amp;mtx, mymtx, NULL) != NULL)
            CloseHandle(mymtx);
        }

        WaitForSingleObject(mtx, 0);
        if (!initialized)
        {
          libInitInternal();
          initialized = 1;
        }
        ReleaseMutex(mtx);
    }
    return singletonInstance;
    };

private:
  CString m_hostServiceAddress;
  CString m_coupon;

  static void libInitInternal()
  {
    singletonInstance = new AddinProcessService();
  }
};

</code></pre>

<p>❗️ Vergeet niet in de cpp file uw singletonInstance pointer te declareren, anders krijg je linker errors: <code>AddinProcessService* AddinProcessService::singletonInstance;</code></p>

<p>In UNIX kan men <a href="https://computing.llnl.gov/tutorials/pthreads/">pthreads</a> gebruiken, ongeveer op deze manier:</p>

<pre><code class="language-c++">static Foo &amp;getInst()
{
  static Foo *inst = NULL;
  if(inst ###### NULL)
  {
    pthread_mutex_lock(&amp;mutex);
    if(inst ###### NULL)
      inst = new Foo(...);
    pthread_mutex_unlock(&amp;mutex);
  }
  return *inst;    
}
</code></pre>

<p>Dan kan je <code>#ifdef WIN32</code> gebruiken om te switchen tussen beide implementaties.</p>

<h4 id="c-11-multithreading">C++ 11 multithreading</h4>

<p>Vanaf C++ 11 zijn multithreads 100% native supported, dit wil zeggen dat manueel locken met een <code>mutex</code> overbodig wordt. Bovenstaande singleton kan gereduceerd worden tot (merk het <strong>static</strong> keyword op, dat is het belangrijkste voor de autolock):</p>

<pre><code class="language-c++">static Singleton&amp; get(){
  static Singleton instance;
  return instance;
}
</code></pre>

<p>Voor meer info, zie <a href="http://stackoverflow.com/questions/11711920/how-to-implement-multithread-safe-singleton-in-c11-without-using-mutex">http://stackoverflow.com/questions/11711920/how-to-implement-multithread-safe-singleton-in-c11-without-using-mutex</a></p>

<h1 id="win32-api-specifics">Win32 API specifics</h1>

<h4 id="get-loaded-dll-info-from-given-process">Get Loaded DLL info from given process</h4>

<p>huidig proces: <code>GetCurrentProcessId()</code> - dit is een <code>HANDLE</code>.</p>

<pre><code class="language-c++">CString ExceptionHandler::GetLoadedDllInfo() const
{
  CString dlls = _T(&quot;&quot;);
  HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, GetCurrentProcessId());
  if(process ###### NULL)
  {
    return dlls;
  }

   HMODULE hMods[1024];
   DWORD cbNeeded;
   BOOL modules = EnumProcessModules(process, hMods, sizeof(hMods), &amp;cbNeeded);
   if(!modules)
   {
     return dlls;
   }

  for (int i = 0; i &lt; (cbNeeded / sizeof(HMODULE)); i++)
  {
    TCHAR szModName[MAX_PATH];

    if (GetModuleFileNameEx(process, hMods[i], szModName, sizeof(szModName) / sizeof(TCHAR)))
    {
      dlls.Format(_T(&quot;%s, %s&quot;), dlls, szModName);
    }
  }

  CloseHandle(process);
  return dlls;
}
</code></pre>

<p>Hiervoor moet je <code>#include &lt;psapi.h&gt;</code> includen én de psapi.lib file mee linken! Zie <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682631(v=vs.85).aspx">EnumProcessModules MSDN</a>.</p>

<h1 id="c-native-calls-uitvoeren">C++ Native calls uitvoeren</h1>

<h4 id="voorbeeld-project">Voorbeeld project</h4>

<p>Wat is het probleem:</p>

<ol>
<li>Ik wil Native C++ methods kunnen aanroepen vanuit C#. Dit kan met de <code>DllImport</code> attribute.</li>
<li>Ik wil structs kunnen remarshallen die uit de native code komen. Dit kan met <code>StructLayout</code> en <code>PtrToStructrue</code>.</li>
<li>Ik wil een char* mappen op een C# string: gebruik <code>[MarshalAsAttribute(UnmanagedType.LPStr)]</code> in uw C# struct.</li>
<li>Ik wil parameters mee kunnen geven: gebruik de juiste calling method (STD of DECL) instelling, zie <code>CallingConvention</code> op <code>UnmanagedFunctionPointer</code>.</li>
</ol>

<pre><code class="language-c++">#pragma once

#ifdef _DLL 
#define DllExImport __declspec(dllexport) 
#else 
#define DllExImport __declspec(dllimport) 
#endif

struct MyStruct
{
  char* id;
  char* description;
};

DllExImport MyStruct* __stdcall GetSignals();
</code></pre>

<pre><code class="language-c++">#include &quot;stdafx.h&quot;
#include &quot;TestClass.h&quot;

DllExImport MyStruct* __stdcall GetSignals()
{
  static MyStruct a[] =
  {
    { &quot;id1&quot;, &quot;desc1&quot; },
    { &quot;id2&quot;, &quot;desc2&quot; },
    { &quot;id3&quot;, &quot;desc3&quot; }
  };
  return a;
}
</code></pre>

<pre><code class="language-csharp">namespace structArrayImportTest
{
    #region

    using System;
    using System.Runtime.InteropServices;

    #endregion

    internal class StructImporter
    {
        // Charset.Ansi is not needed it seems
        [DllImport(&quot;kernel32.dll&quot;, EntryPoint = &quot;LoadLibrary&quot;)]
        private static extern IntPtr LoadLibrary(
            [MarshalAs(UnmanagedType.LPStr)] string lpLibFileName);

        [DllImport(&quot;kernel32.dll&quot;, EntryPoint = &quot;GetProcAddress&quot;)]
        private static extern IntPtr GetProcAddress(IntPtr hModule,
                                                    [MarshalAs(UnmanagedType.LPStr)] string lpProcName);

        [DllImport(&quot;kernel32&quot;, SetLastError ###### true, EntryPoint  &quot;GetProcAddress&quot;)]
        private static extern IntPtr GetProcAddressOrdinal(IntPtr hModule, IntPtr procName);

        [DllImport(&quot;kernel32.dll&quot;, EntryPoint = &quot;FreeLibrary&quot;)]
        private static extern bool FreeLibrary(int hModule);

        [StructLayout(LayoutKind.Sequential)]
        public class MyStruct
        {
            [MarshalAsAttribute(UnmanagedType.LPStr)]
            public string _id;
            [MarshalAsAttribute(UnmanagedType.LPStr)]
            public string _description;
        }

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate IntPtr fGetSignals();

        public fGetSignals GetSignals;

        public void Import()
        {
            IntPtr lib = LoadLibrary(@&quot;C:&lt;br/&gt;Users&lt;br/&gt;bkwog&lt;br/&gt;Documents&lt;br/&gt;Visual Studio 2012&lt;br/&gt;Projects&lt;br/&gt;structArrayExportTest&lt;br/&gt;Debug&lt;br/&gt;structArrayExportTest.dll&quot;);
            // gebruik dumpbin /exports [bla.dll] om ordinal &amp; name van exported functions te bepalen.
            IntPtr signalsHandle = GetProcAddressOrdinal(lib, new IntPtr(1));
            GetSignals = (fGetSignals) Marshal.GetDelegateForFunctionPointer(signalsHandle, typeof (fGetSignals));
            IntPtr myStructs = GetSignals();

            int structSize = Marshal.SizeOf(typeof(MyStruct));
            Console.WriteLine(structSize);

            for (int i = 0; i &lt; 3; ++i)
            {
                // What's the difference between toInt32 &amp; 64 here? Both work...
                IntPtr data = new IntPtr(myStructs.ToInt64() + structSize * i);
                MyStruct ms = (MyStruct)Marshal.PtrToStructure(data, typeof(MyStruct));

                Console.WriteLine(&quot;id: &quot; + ms._id + &quot; - descr: &quot; + ms._description );
            }
        }

    }
}
</code></pre>

<h4 id="calling-convention">Calling convention</h4>

<p>In te stellen via C++ project settings -&gt; advanced -&gt; calling convention, voor alles, of per functie met <code>__stdcall</code>. C# werkt hiet default mee. Aanpasbaar in het attribute, zie boven.</p>

<p>Als de calling convention niet overeen zou komen, krijg je bij het uitvoeren in de C# code de volgende fout:</p>

<blockquote>
<p>call to PInvoke function &lsquo;structArrayImportTest!structArrayImportTest.StructImporter+fGetSignals::Invoke&rsquo; has unbalanced the stack. This is likely because the managed PInvoke signature does not match the unmanaged target signature. Check that the calling convention and parameters of the PInvoke signature match the target unmanaged signature.</p>
</blockquote>

<h4 id="dumpbin">dumpbin</h4>

<p>Als je niet met ordinals wenst te werken maar de volledige naam van de functie kan jet met <code>dumpbin.exe</code> dit achterhalen:</p>

<pre><code>C:&lt;br/&gt;Program Files (x86)&lt;br/&gt;Microsoft Visual Studio 10.0&lt;br/&gt;Common7&lt;br/&gt;IDE&gt;dumpbin /exports TfsAdmin.exe structArrayExportTest.dll
Microsoft (R) COFF/PE Dumper Version 10.00.40219.01
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file TfsAdmin.exe

File Type: EXECUTABLE IMAGE

Dump of file structArrayExportTest.dll

File Type: DLL

  Section contains the following exports for structArrayExportTest.dll

    00000000 characteristics
    52A888CA time date stamp Wed Dec 11 16:46:18 2013
        0.00 version
           1 ordinal base
           2 number of functions
           2 number of names

    ordinal hint RVA      name

          1    0 00011113 ?GetSignals@@YAPAUTestStruct@@XZ
          2    1 000110E6 ?GetSize@@YAPAHXZ

  Summary

        1000 .data
        1000 .idata
        3000 .rdata
        3000 .reloc
       11000 .rsrc
        8000 .text
       10000 .textbss
</code></pre>

<p>Merk op dat de functie <code>GetSignals</code> hier niet die naam heeft, maar <code>?GetSignals@@YAPAUTestStruct@@XZ</code>!</p>
</div>

    
    

    

    
    
    <h4 class="page-header"><i class="fa fa-comments-o"></i>&nbsp;
        
            Join the Discussion on 
        
        <a href="https://twitter.com/woutergroenev">Twitter</a>!</h4>

        

    

    <i class='fa fa-arrow-circle-o-up'></i>&nbsp;<a href="#top">Top</a> 

</main>

        <footer>

            <p class="copyright text-muted">No <i class='fa fa-copyright'></i> reserved - sharing is caring. <i class='fa fa-github'></i> <a href='https://github.com/wgroeneveld/brainbaking/'>Hack away</a>! <i class='fa fa-lightbulb-o'></i> <a href='/'>Brain Baking</a></p>

        </footer>
       
    </body>

</html>

